<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>页面打印表格换页问题</title>
    <link href="/evanyoungblog.gitee.io/2022/05/18/%E9%A1%B5%E9%9D%A2%E6%89%93%E5%8D%B0%E8%A1%A8%E6%A0%BC%E6%8D%A2%E9%A1%B5%E9%97%AE%E9%A2%98/"/>
    <url>/evanyoungblog.gitee.io/2022/05/18/%E9%A1%B5%E9%9D%A2%E6%89%93%E5%8D%B0%E8%A1%A8%E6%A0%BC%E6%8D%A2%E9%A1%B5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="打印HTML页面时，表格table过长导致分页错行问题"><a href="#打印HTML页面时，表格table过长导致分页错行问题" class="headerlink" title="打印HTML页面时，表格table过长导致分页错行问题"></a>打印HTML页面时，表格table过长导致分页错行问题</h2><p>在打印一个html页面时，会出现table数据过长，需要分多个页面打印，这时候会出现一行切成两行，导致表格行错乱。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>可以在媒体打印中添加下面几行代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-keyword">@media</span> print</span><br><span class="language-css">&#123;</span><br><span class="language-css">  <span class="hljs-selector-tag">table</span> &#123; <span class="hljs-attribute">page-break-after</span>:auto &#125;</span><br><span class="language-css">  <span class="hljs-selector-tag">tr</span>    &#123; <span class="hljs-attribute">page-break-inside</span>:avoid; <span class="hljs-attribute">page-break-after</span>:auto &#125;</span><br><span class="language-css">  <span class="hljs-selector-tag">td</span>    &#123; <span class="hljs-attribute">page-break-inside</span>:avoid; <span class="hljs-attribute">page-break-after</span>:auto &#125;</span><br><span class="language-css">  <span class="hljs-selector-tag">thead</span> &#123; <span class="hljs-attribute">display</span>:table-header-group &#125;//表格的行头</span><br><span class="language-css">  <span class="hljs-selector-tag">tfoot</span> &#123; <span class="hljs-attribute">display</span>:table-footer-group &#125; //表格的行尾</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后会发现表格会根据打印页面的大小进行分行，不会出现一行数据被分成两页的情况了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elementUI合并相同数据列</title>
    <link href="/evanyoungblog.gitee.io/2022/05/13/elementUI%E5%90%88%E5%B9%B6%E7%9B%B8%E5%90%8C%E6%95%B0%E6%8D%AE%E5%88%97/"/>
    <url>/evanyoungblog.gitee.io/2022/05/13/elementUI%E5%90%88%E5%B9%B6%E7%9B%B8%E5%90%8C%E6%95%B0%E6%8D%AE%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="elementUI-表格-如何合并相同数据的列？"><a href="#elementUI-表格-如何合并相同数据的列？" class="headerlink" title="elementUI 表格 如何合并相同数据的列？"></a>elementUI 表格 如何合并相同数据的列？</h2><p>在编写表格table中，会出现合并数据相同的列这种需求，如图：</p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/elementui-%E7%AC%94%E8%AE%B0/objectSpanMethod.PNG"></p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>添加span-method 方法，elementUI提供了span-method方法 让我们可以动态合并表格，其中有四个参数，分别是row, column, rowIndex, columnIndex</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--   <br>row:代表当前行的值<br>column:代表当前列的值<br>rowIndex:当前行的索引<br>columnIndex:当前列的索引<br>--&gt;<br><br>&lt;el-table :data=&quot;tableData&quot; :span-method=&quot;objectSpanMethod&quot; &gt;<br><br>&lt;!--objectSpanMethod是定义的逻辑方法，可以根据自己需求定义--&gt;<br></code></pre></td></tr></table></figure><p>objectSpanMethod的具体实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setdates</span>(<span class="hljs-params">arr</span>) &#123;   <span class="hljs-comment">//获取数组</span><br>        <span class="hljs-keyword">var</span> obj = &#123;&#125;,<br>          k, arr1 = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>          k = arr[i].<span class="hljs-property">date</span>;<span class="hljs-comment">//合并所需要的列</span><br>          <span class="hljs-keyword">if</span>(obj[k])<br>            obj[k]++;<br>          <span class="hljs-keyword">else</span><br>            obj[k] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br>        <span class="hljs-comment">//保存结果&#123;el-&#x27;元素&#x27;，count-出现次数&#125;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> o <span class="hljs-keyword">in</span> obj) &#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;obj[o];i++)&#123;<br>            <span class="hljs-keyword">if</span>(i===<span class="hljs-number">0</span>)&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr1</span>.<span class="hljs-title function_">push</span>(obj[o])<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr1</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">0</span>)<br>            &#125;<br>          &#125;<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr1</span>);<br><br>      &#125;,<br>      <span class="hljs-title function_">objectSpanMethod</span>(<span class="hljs-params">&#123; row, column, rowIndex, columnIndex &#125;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (columnIndex === <span class="hljs-number">0</span> ) &#123;<br>          <span class="hljs-keyword">let</span> _row = <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr1</span>[rowIndex]<br>          <span class="hljs-keyword">let</span> _col = <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr1</span>[rowIndex] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span><br>          <span class="hljs-keyword">return</span> [_row,_col]<br>        &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;el-table<br>    :data=&quot;tableData&quot;<br>    border<br>    style=&quot;width: 100%&quot;  :span-method=&quot;objectSpanMethod&quot; &gt;<br>    &lt;el-table-column<br>      prop=&quot;date&quot;<br>      label=&quot;日期&quot;<br>      width=&quot;180&quot;&gt;<br>    &lt;/el-table-column&gt;<br>    &lt;el-table-column<br>      prop=&quot;name&quot;<br>      label=&quot;姓名&quot;<br>      width=&quot;180&quot;&gt;<br>    &lt;/el-table-column&gt;<br>    &lt;el-table-column<br>      prop=&quot;address&quot;<br>      label=&quot;地址&quot;&gt;<br>    &lt;/el-table-column&gt;<br>  &lt;/el-table&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    name: &quot;table&quot;,<br>    data() &#123;<br>      return &#123;<br>        tableData: [&#123;<br>          date: &#x27;2016-05-02&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1518 弄&#x27;<br>        &#125;, &#123;<br>          date: &#x27;2016-05-02&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1517 弄&#x27;<br>        &#125;, &#123;<br>          date: &#x27;2016-05-01&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1519 弄&#x27;<br>        &#125;, &#123;<br>          date: &#x27;2016-05-03&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1516 弄&#x27;<br>        &#125;],<br>        arr1:[],<br>        arr2:[]<br>      &#125;<br>    &#125;,<br>    created() &#123;<br>      this.setdates(this.tableData)<br>    &#125;,<br>    methods: &#123;<br>      setdates(arr) &#123;<br>        var obj = &#123;&#125;,<br>          k, arr1 = [];<br>        for(var i = 0, len = arr.length; i &lt; len; i++) &#123;<br>          k = arr[i].date;//需要合并的字段<br>          if(obj[k])<br>            obj[k]++;<br>          else<br>            obj[k] = 1;<br>        &#125;<br>        console.log(obj)<br>        //保存结果&#123;el-&#x27;元素&#x27;，count-出现次数&#125;<br>        for(var o in obj) &#123;<br>          for(let i=0;i&lt;obj[o];i++)&#123;<br>            if(i===0)&#123;<br>              this.arr1.push(obj[o])<br>            &#125;else&#123;<br>              this.arr1.push(0)<br>            &#125;<br>          &#125;<br>        &#125;<br>        console.log(this.arr1);<br><br>      &#125;,<br><br><br>      objectSpanMethod(&#123; row, column, rowIndex, columnIndex &#125;) &#123;<br>        if (columnIndex === 0 ) &#123;<br>          let _row = this.arr1[rowIndex]<br>          let _col = this.arr1[rowIndex] &gt; 0 ? 1 : 0<br>          return [_row,_col]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;;<br>&lt;/script&gt;<br><br><br><br>&lt;style scoped&gt;<br><br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elementUI修改表头指定列</title>
    <link href="/evanyoungblog.gitee.io/2022/05/13/elementUI%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%A4%B4%E6%8C%87%E5%AE%9A%E5%88%97/"/>
    <url>/evanyoungblog.gitee.io/2022/05/13/elementUI%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%A4%B4%E6%8C%87%E5%AE%9A%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="elementUI如何修改表头的某一列样式？"><a href="#elementUI如何修改表头的某一列样式？" class="headerlink" title="elementUI如何修改表头的某一列样式？"></a>elementUI如何修改表头的某一列样式？</h2><p>今天碰到个需求，要在elementUI 的表格头上根据不同的列名称改变颜色。</p><p>如图所示：</p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/elementui-%E7%AC%94%E8%AE%B0/headerRowStyle.PNG"></p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">//调用headerRowStyle方法<br>&lt;el-table :data=&quot;tableData&quot; border :header-cell-style=&quot;headerRowStyle&quot;&gt;<br></code></pre></td></tr></table></figure><p>定义headerRowStyle方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">headerRowStyle</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-comment">//根据列的标签名来指定修改</span><br>       <span class="hljs-keyword">if</span>(obj.<span class="hljs-property">column</span>.<span class="hljs-property">label</span>==<span class="hljs-string">&quot;日期&quot;</span>)&#123; <br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;color: #fff;background:#00bfbf&#x27;</span><br>       &#125;<br>       <span class="hljs-keyword">if</span>(obj.<span class="hljs-property">column</span>.<span class="hljs-property">label</span>==<span class="hljs-string">&quot;姓名&quot;</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;color: #fff;background:#ffd454&#x27;</span><br>       &#125;<br>       <span class="hljs-keyword">if</span>(obj.<span class="hljs-property">column</span>.<span class="hljs-property">label</span>==<span class="hljs-string">&quot;地址&quot;</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;color:#00ffff&#x27;</span><br>       &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;el-table<br>    :data=&quot;tableData&quot;<br>    border<br>    style=&quot;width: 100%&quot; :header-cell-style=&quot;headerRowStyle&quot;&gt;<br>    &lt;el-table-column<br>      prop=&quot;date&quot;<br>      label=&quot;日期&quot;<br>      width=&quot;180&quot;&gt;<br>    &lt;/el-table-column&gt;<br>    &lt;el-table-column<br>      prop=&quot;name&quot;<br>      label=&quot;姓名&quot;<br>      width=&quot;180&quot;&gt;<br>    &lt;/el-table-column&gt;<br>    &lt;el-table-column<br>      prop=&quot;address&quot;<br>      label=&quot;地址&quot;&gt;<br>    &lt;/el-table-column&gt;<br>  &lt;/el-table&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    name: &quot;table&quot;,<br>    data() &#123;<br>      return &#123;<br>        tableData: [&#123;<br>          date: &#x27;2016-05-02&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1518 弄&#x27;<br>        &#125;, &#123;<br>          date: &#x27;2016-05-04&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1517 弄&#x27;<br>        &#125;, &#123;<br>          date: &#x27;2016-05-01&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1519 弄&#x27;<br>        &#125;, &#123;<br>          date: &#x27;2016-05-03&#x27;,<br>          name: &#x27;王小虎&#x27;,<br>          address: &#x27;上海市普陀区金沙江路 1516 弄&#x27;<br>        &#125;]<br>      &#125;<br>    &#125;,<br>    created() &#123;<br>      this.setdates(this.tableData)<br>    &#125;,<br>    methods: &#123;<br><br><br>      headerRowStyle(obj)&#123;<br><br><br>        if(obj.column.label==&quot;日期&quot;)&#123;<br>          return &#x27;color: #fff;background:#00bfbf&#x27;<br>        &#125;<br>        if(obj.column.label==&quot;姓名&quot;)&#123;<br>          return &#x27;color: #fff;background:#ffd454&#x27;<br>        &#125;<br>        if(obj.column.label==&quot;地址&quot;) &#123;<br>          return &#x27;color:#00ffff&#x27;<br>        &#125;<br>      &#125;,<br>    &#125;<br>  &#125;;<br>&lt;/script&gt;<br><br><br><br>&lt;style scoped&gt;<br><br>&lt;/style&gt;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;meta&gt;标签name=viewport详解</title>
    <link href="/evanyoungblog.gitee.io/2022/04/02/meta-%E6%A0%87%E7%AD%BEname-viewport%E8%AF%A6%E8%A7%A3/"/>
    <url>/evanyoungblog.gitee.io/2022/04/02/meta-%E6%A0%87%E7%AD%BEname-viewport%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="lt-meta-gt-标签-name-”viewport”-详解"><a href="#lt-meta-gt-标签-name-”viewport”-详解" class="headerlink" title="&lt;meta&gt;标签 name=”viewport” 详解"></a><code>&lt;meta&gt;</code>标签 name=”viewport” 详解</h1><p>今天给老板做的驾驶舱基本完成了，准备投到电视机大屏上看下效果，结果出现页面显示大小不对，于是看看是不是分辨率的问题，最后发现了我html页面的<code>&lt;meta&gt;</code>标签设置了不能缩放，最后修改成下面语句，成功显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=1680&quot;</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>记个笔记…</p><h4 id="什么是Viewport"><a href="#什么是Viewport" class="headerlink" title="什么是Viewport"></a>什么是Viewport</h4><p>通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。</p><h4 id="Viewport-基础"><a href="#Viewport-基础" class="headerlink" title="Viewport 基础"></a>Viewport 基础</h4><p>一个常用的针对移动网页优化过的页面的 viewport meta 标签大致如下：<br> <code>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1″&gt;</code><br> <code>width</code>：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）<br> <code>height</code>：和 width 相对应，指定高度<br> <code>initial-scale</code>：初始缩放比例，也即是当页面第一次 load 的时候缩放比例<br> <code>maximum-scale</code>：允许用户缩放到的最大比例<br> <code>minimum-scale</code>：允许用户缩放到的最小比例<br> <code>user-scalable</code>：用户是否可以手动缩放</p><p>下面的一行代码可以让网页的宽度自动适应手机屏幕的宽度:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WhiteJotter</title>
    <link href="/evanyoungblog.gitee.io/2022/03/25/WhiteJotter/"/>
    <url>/evanyoungblog.gitee.io/2022/03/25/WhiteJotter/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在csdn上看到一个vue+springboot的项目实战教程很不错：<a href="https://learner.blog.csdn.net/article/details/88925013%EF%BC%8C">https://learner.blog.csdn.net/article/details/88925013，</a></p><p>跟着做一下，锻炼一下自己。本文旨在记录下开发过程中遇到的问题和解决方法。</p><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>如果前端打包之后dist文件夹下面的文件copy到后端static目录下 ，访问<code> http://localhost:8080/index.html</code> 这个地址，没有出现作者说的获取到一个空白页面而是出现了404报错，可以在idea中，找到项目结构（快捷键：ctrl+alt+shift+s），选择工件，添加一个空的JAR类型的工件，再重新运行项目，访问<code>http://localhost:8080/index.html</code>这个地址会正常出现作者说的空白页面，<code>http://localhost:8080/login</code>，如果没有设置后端ErrorConfig,会出现作者说的错误页，设置后则会正常出现登录界面。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">//引入vuex的时候报错<br>D:\study\ey-vue&gt;npm install vuex --save<br>npm ERR! code ERESOLVE<br>npm ERR! ERESOLVE unable to resolve dependency tree<br>npm ERR!<br>npm ERR! While resolving: my-project@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br>npm ERR! Found: vue@<span class="hljs-number">2.6</span>.<span class="hljs-number">14</span><br>npm ERR! node_modules/vue<br>npm ERR!   vue@<span class="hljs-string">&quot;^2.5.2&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Could not resolve dependency:<br>npm ERR! peer vue@<span class="hljs-string">&quot;^3.0.2&quot;</span> from vuex@<span class="hljs-number">4.0</span>.<span class="hljs-number">2</span><br>npm ERR! node_modules/vuex<br>npm ERR!   vuex@<span class="hljs-string">&quot;*&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Fix the upstream dependency conflict, or retry<br>npm ERR! this command with --force, or --legacy-peer-deps<br>npm ERR! to accept an incorrect (and potentially broken) dependency resolution.<br>npm ERR!<br>npm ERR! See C:\Users\Evan\AppData\Local\npm-cache\eresolve-report.txt for a full report.<br><br>npm ERR! A complete log of this run can be found in:<br>npm ERR!     C:\Users\Evan\AppData\Local\npm-cache\_logs\<span class="hljs-number">2022</span>-<span class="hljs-number">03</span>-<span class="hljs-number">24</span>T09_36_10_865Z-debug-<span class="hljs-number">0</span>.log<br><br></code></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install vuex@<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> -S<br></code></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p><strong>报错:</strong></p><p>添加修改图书时，选择分类，只有第一次点击才有图书分类,并且console报错。</p><p><strong>错误原因</strong></p><p>editForm里面的clear()有问题，执行之后会造成category的属性丢失，从而导致连续添加图书的时候，第二次会出现无法选择图书分类，而且console报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">clear () &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">form</span> = &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">date</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">press</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">cover</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">abs</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>       <span class="hljs-comment">//原因：</span><br>          <span class="hljs-attr">category</span>: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>   &#125;,<br></code></pre></td></tr></table></figure><p><strong>解决方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//可以将clear中category属性赋空，而不是将category赋值为空</span><br><span class="hljs-attr">category</span>: &#123;<br>             <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>             <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span><br>           &#125;<br></code></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p><strong>出错：</strong></p><p> 教程添加“文件上传”的模块后，没有“点击上传”按钮，</p><p><strong>解决方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ImgUpload</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ImgUpload&#x27;</span><br>      <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;EditForm&#x27;</span>,<br>        <span class="hljs-attr">components</span>: &#123;<span class="hljs-title class_">ImgUpload</span>&#125;,<span class="hljs-comment">//导入时还要加入这一行代码</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis笔记</title>
    <link href="/evanyoungblog.gitee.io/2022/03/21/Mybatis%E7%AC%94%E8%AE%B0-1/"/>
    <url>/evanyoungblog.gitee.io/2022/03/21/Mybatis%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis笔记"><a href="#Mybatis笔记" class="headerlink" title="Mybatis笔记"></a>Mybatis笔记</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-三层架构"><a href="#1-三层架构" class="headerlink" title="1.三层架构"></a>1.三层架构</h3><p>界面层： 和用户打交道的， 接收用户的请求参数， 显示处理结果的。（jsp ，html ，servlet）<br>业务逻辑层： 接收了界面层传递的数据，计算逻辑，调用数据库，获取数据<br>数据访问层： 就是访问数据库， 执行对数据的查询，修改，删除等等的。</p><pre><code class="hljs"> 三层对应的包   界面层： controller包 （servlet）   业务逻辑层： service 包（XXXService类）   数据访问层： dao包（XXXDao类） 三层中类的交互   用户使用界面层--&gt; 业务逻辑层---&gt;数据访问层（持久层）--&gt;数据库（mysql）  三层对应的处理框架   界面层---servlet---springmvc（框架）   业务逻辑层---service类--spring（框架）   数据访问层---dao类--mybatis（框架）</code></pre><h3 id="2-框架"><a href="#2-框架" class="headerlink" title="2.框架"></a>2.框架</h3><ul><li><p>框架是一个舞台， 一个模版</p></li><li><p>模版：</p><ul><li>规定了好一些条款，内容。</li><li>加入自己的东西</li></ul></li><li><p>框架是一个模块</p><pre><code class="hljs">1.框架中定义好了一些功能。这些功能是可用的。2.可以加入项目中自己的功能， 这些功能可以利用框架中写好的功能。</code></pre></li><li><p>框架是一个软件，半成品的软件，定义好了一些基础功能， 需要加入你的功能就是完整的。<br>   基础功能是可重复使用的，可升级的。</p></li><li><p>框架特点：</p><ul><li><p>框架一般不是全能的， 不能做所有事情</p></li><li><p>框架是针对某一个领域有效。 特长在某一个方面，比如mybatis做数据库操作强，但是他不能做其它的。</p></li><li><p>框架是一个软件</p></li></ul></li></ul><p> <strong>mybatis框架</strong><br>   一个框架，早期叫做ibatis,  代码在github。<br>   mybatis是 MyBatis SQL Mapper Framework for Java （sql映射框架）</p><ul><li><p>1）sql mapper :sql映射</p><pre><code class="hljs">     可以把数据库表中的一行数据  映射为 一个java对象。       一行数据可以看做是一个java对象。操作这个对象，就相当于操作表中的数据</code></pre></li><li><p>2） Data Access Objects（DAOs） : 数据访问 ， 对数据库执行增删改查。</p></li></ul><p><strong>mybatis提供了哪些功能：</strong></p><ul><li><p>1.提供了创建Connection ,Statement, ResultSet的能力 ，不用开发人员创建这些对象</p></li><li><p>2.提供了执行sql语句的能力， 不用你执行sql</p></li><li><p>3.提供了循环sql， 把sql的结果转为java对象， List集合的能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (rs.next()) &#123;<br><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>stu.setId(rs.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>stu.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>stu.setAge(rs.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br><span class="hljs-comment">//从数据库取出数据转为 Student 对象，封装到 List 集合</span><br>stuList.add(stu);<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>4.提供了关闭资源的能力，不用你关闭Connection, Statement, ResultSet</p></li></ul><h4 id="开发人员做的是：-提供sql语句"><a href="#开发人员做的是：-提供sql语句" class="headerlink" title="开发人员做的是： 提供sql语句"></a>开发人员做的是： 提供sql语句</h4><p> 最后是： 开发人员提供sql语句–mybatis处理sql—开发人员得到List集合或java对象（表中的数据）</p><p><strong>总结：</strong><br>  mybatis是一个sql映射框架，提供的数据库的操作能力。增强的JDBC,<br>  使用mybatis让开发人员集中精神写sql就可以了，不必关心Connection,Statement,ResultSet<br>  的创建，销毁，sql的执行。 </p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="主要类的介绍"><a href="#主要类的介绍" class="headerlink" title="主要类的介绍"></a>主要类的介绍</h3><ul><li><ol><li>Resources： mybatis中的一个类， 负责读取主配置文件<pre><code class="hljs"> `InputStream in = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);`</code></pre></li></ol></li><li><ol start="2"><li>SqlSessionFactoryBuilder : 创建SqlSessionFactory对象，</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br><span class="hljs-comment">//创建SqlSessionFactory对象</span><br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> builder.build(in);<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li><code>SqlSessionFactory </code>： 重量级对象， 程序创建一个对象耗时比较长，使用资源比较多。在整个项目中，有一个就够用了。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">SqlSessionFactory:接口  ， 接口实现类： DefaultSqlSessionFactory<br> SqlSessionFactory作用： 获取SqlSession对象。<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> factory.openSession();<br><br> openSession()方法说明：<br>  <span class="hljs-number">1.</span> openSession() ：无参数的， 获取是非自动提交事务的SqlSession对象<br>  <span class="hljs-number">2.</span> openSession(<span class="hljs-type">boolean</span>): openSession(<span class="hljs-literal">true</span>)  获取自动提交事务的SqlSession. <br>                         openSession(<span class="hljs-literal">false</span>)  非自动提交事务的SqlSession对象<br></code></pre></td></tr></table></figure><ul><li><ol start="4"><li><code>SqlSession</code>:<br>   SqlSession接口 ：定义了操作数据的方法 例如 selectOne() ,selectList() ,insert(),update(), delete(), commit(), rollback().<br>   SqlSession接口的实现类DefaultSqlSession。</li></ol></li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">使用要求：<br>SqlSession对象不是线程安全的，需要在方法内部使用。<br>在执行sql语句之前，使用openSession()获取SqlSession对象。<br>在执行完sql语句后，需要关闭它，执行SqlSession.close(). 这样能保证他的使用是线程安全的。<br></code></pre></td></tr></table></figure><hr><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><ul><li><p>动态代理： 使用<code>SqlSession.getMapper(dao接口.class)</code> 获取这个dao接口的对象</p></li><li><p>传入参数： 从java代码中把数据传入到mapper文件的sql语句中。</p><ul><li><p>parameterType ： 写在mapper文件中的一个属性。 表示dao接口中方法的参数的数据类型。<br>例如：StudentDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Student  <span class="hljs-title function_">selectStudentById</span><span class="hljs-params">(Integer id)</span> <br></code></pre></td></tr></table></figure></li><li><p>一个简单类型的参数：<br>简单类型： mybatis把java的基本数据类型和String都叫简单类型。<br>在mapper文件获取简单类型的一个参数的值，使用 #{任意字符}</p></li></ul><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Student  <span class="hljs-title function_">selectStudentById</span><span class="hljs-params">(Integer id)</span> <br></code></pre></td></tr></table></figure><p>mapper:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name, email,age <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;studentId&#125;<br></code></pre></td></tr></table></figure></li><li><p>参数，使用@Param命名参数</p><p>接口 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectMulitParam</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;myname&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;myage&quot;)</span> Integer age)</span><br>  使用  <span class="hljs-meta">@Param(&quot;参数名&quot;)</span>  String name <br></code></pre></td></tr></table></figure><p>mapper:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>#&#123;myname&#125; <span class="hljs-keyword">or</span> age<span class="hljs-operator">=</span>#&#123;myage&#125;<br>  <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>多个参数，使用java对象<br>语法 #{属性名}</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">vo: <span class="hljs-keyword">value</span> <span class="hljs-keyword">object</span> , 放一些存储数据的类。比如说 提交请求参数， <span class="hljs-type">name</span> ,age <br>     现在想把<span class="hljs-type">name</span> ,age 传给一个service 类。<br>vo: <span class="hljs-keyword">view</span> <span class="hljs-keyword">object</span> , 从servlet把数据返回给浏览器使用的类，表示显示结果的类。<br><br>pojo: 普通的有<span class="hljs-keyword">set</span>， <span class="hljs-keyword">get</span>方法的java类。普通的java对象<br><br>Servlet: StudentService( addStudent( MyParam  param)  )<br><br>entity（<span class="hljs-keyword">domain</span>域）: 实体类， 和数据库中的表对应的类。<br></code></pre></td></tr></table></figure></li></ul><h4 id="和-重点"><a href="#和-重点" class="headerlink" title="#和$:[重点]"></a><strong>#和$</strong>:[重点]</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name, email,age <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;studentId&#125;<br>  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> # 的结果： <br><span class="hljs-keyword">select</span> id,name, email,age <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>? <br><br><span class="hljs-keyword">select</span> id,name, email,age <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$&#123;studentId&#125;<br>  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> $ 的结果：<br><span class="hljs-keyword">select</span> id,name, email,age <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1001</span><br></code></pre></td></tr></table></figure><ul><li>  $:可以替换表名或者列名， 你能确定数据是安全的。可以使用$</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-params">#</span>和<span class="hljs-built_in">$</span> 区别<br>        <span class="hljs-params">#</span>&#123;&#125; 是 占位符 ：动态解析 -&gt; 预编译 -&gt; 执行<br>        <span class="hljs-built_in">$</span>&#123;&#125; 是 拼接符 ：动态解析 -&gt; 编译 -&gt; 执行<br>1. <span class="hljs-params">#</span>使用?在sql语句中做占位的， 使用PreparedStatement执行sql，效率高<br>2. <span class="hljs-params">#</span>能够避免sql注入，更安全。<br>3. <span class="hljs-built_in">$</span>不使用占位符，是字符串连接方式，使用Statement对象执行sql，效率低<br>4. <span class="hljs-built_in">$</span>有sql注入的风险，缺乏安全性。<br>5. <span class="hljs-built_in">$</span>:可以替换表名或者列名<br>6. Mybatis默认值不同<br>  <span class="hljs-params">#</span>&#123;&#125; 默认值 arg0、arg1、arg2  或 0、 1<br>这里用Mybatis默认的 0 和 1 来代替传参，根据版本不同，也可能是用arg0、arg1、arg2，<br>或者 param1 、param2 ，可以根据报错信息进行修改。<br>  <span class="hljs-built_in">$</span>&#123;&#125; 默认值param1、param2、param3<br><span class="hljs-built_in">$</span>&#123;&#125; 时，用 0 和 1虽然不会报错，但是会直接当成参数执行。一般默认参数是param1、param2<br></code></pre></td></tr></table></figure><p>什么是SQL注入？</p><p>通过传参就能改变SQL语句原本规则的操作就是SQL注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">如果用$传参 name <span class="hljs-operator">=</span> &quot;jack or name = lisa&quot;，<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> `role` <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> $&#123;name&#125;<br>因为$&#123;&#125;是拼接符，会直接替换，所以实际是：<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> `role` <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;jack&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;lisa&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="mybatis的输出结果"><a href="#mybatis的输出结果" class="headerlink" title="mybatis的输出结果"></a>mybatis的输出结果</h4><p>mybatis执行了sql语句，得到java对象。</p><ul><li><code>resultType</code>结果类型， 指sql语句执行完毕后， 数据转为的java对象， java类型是任意的。<br> resultType结果类型的它值 <ul><li>类型的全限定名称  </li><li>类型的别名， 例如 java.lang.Integer别名是int</li></ul></li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">处理方式：<br> 1. mybatis执行sql语句， 然后mybatis调用类的无参数构造方法，创建对象。<br> 2. mybatis把ResultSet指定列值赋给同名的属性。<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;selectMultiPosition&quot; resultType<span class="hljs-operator">=</span>&quot;com.bjpowernode.domain.Student&quot;<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">select</span> id,name, email,age <span class="hljs-keyword">from</span> student<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>​    对等的jdbc:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ResultSet rs = execute<span class="hljs-constructor">Query(<span class="hljs-string">&quot; select id,name, email,age from student&quot;</span> )</span><br>  <span class="hljs-keyword">while</span>(rs.next<span class="hljs-literal">()</span>)&#123;<br>        Student student = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Student()</span>;<br>student.set<span class="hljs-constructor">Id(<span class="hljs-params">rs</span>.<span class="hljs-params">getInt</span>(<span class="hljs-string">&quot;id&quot;</span>)</span>);<br>student.set<span class="hljs-constructor">Name(<span class="hljs-params">rs</span>.<span class="hljs-params">getString</span>(<span class="hljs-string">&quot;name&quot;</span>)</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>定义自定义类型的别名</p><ul><li>在mybatis主配置文件中定义，使<code>&lt;typeAlias&gt;</code>定义别名</li><li>可以在resultType中使用自定义别名</li></ul></li><li><p>resultMap:结果映射， 指定列名和java对象的属性对应关系。</p><ul><li>你自定义列值赋值给哪个属性</li><li>当你的列名和属性名不一样时，一定使用resultMap</li></ul></li></ul><p><strong>resultMap和resultType不要一起用，二选一</strong></p><hr><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><p><strong>sql的内容是变化的，可以根据条件获取到不同的sql语句。</strong><br>    主要是where部分发生变化。</p><p> 动态sql的实现，使用的是mybatis提供的标签， <code>&lt;if&gt; </code>,<code>&lt;where&gt;</code>,<code>&lt;foreach&gt;</code></p><ul><li><code>&lt;if&gt;</code>是判断条件的，</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">语法<br><span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;判断java对象的属性值&quot;<span class="hljs-operator">&gt;</span><br>           部分<span class="hljs-keyword">sql</span>语句<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;where&gt;</code> 用来包含 多个<code>&lt;if&gt;</code>的， 当多个if有一个成立的， <code>&lt;where&gt;</code>会自动增加一个where关键字，</p><pre><code class="hljs">        并去掉 if中多余的 and ，or等。</code></pre></li><li><p><code>&lt;foreach&gt;</code> 循环java中的数组，list集合的。 主要用在sql的in语句中。</p><pre><code class="hljs">学生id是 1001,1002,1003的三个学生</code></pre></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>,<span class="hljs-number">1003</span>)<br><br>public List<span class="hljs-operator">&lt;</span>Student<span class="hljs-operator">&gt;</span> selectFor(List<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span><span class="hljs-operator">&gt;</span> idlist)<br><br>List<span class="hljs-operator">&lt;</span><span class="hljs-type">Integer</span><span class="hljs-operator">&gt;</span> list <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ...<br>list.add(<span class="hljs-number">1001</span>);<br>list.add(<span class="hljs-number">1002</span>);<br>list.add(<span class="hljs-number">1003</span>);<br><br>dao.selectFor(list)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-operator">&lt;</span>foreach collection<span class="hljs-operator">=</span>&quot;&quot; item<span class="hljs-operator">=</span>&quot;&quot; <span class="hljs-keyword">open</span><span class="hljs-operator">=</span>&quot;&quot; <span class="hljs-keyword">close</span><span class="hljs-operator">=</span>&quot;&quot; separator<span class="hljs-operator">=</span>&quot;&quot;<span class="hljs-operator">&gt;</span><br>         #&#123;xxx&#125;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span><br><br>collection:表示接口中的方法参数的类型， 如果是数组使用<span class="hljs-keyword">array</span> , 如果是list集合使用list<br>item:自定义的，表示数组和集合成员的变量<br><span class="hljs-keyword">open</span>:循环开始是的字符<br><span class="hljs-keyword">close</span>:循环结束时的字符<br>separator:集合成员之间的分隔符<br></code></pre></td></tr></table></figure><ul><li><p>sql代码片段， 就是复用一些语法<br>步骤<br>1.先定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">`<span class="hljs-operator">&lt;</span><span class="hljs-keyword">sql</span> id<span class="hljs-operator">=</span>&quot;自定义名称唯一&quot;<span class="hljs-operator">&gt;</span>`  <span class="hljs-keyword">sql</span>语句， 表名，字段等 `<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">sql</span><span class="hljs-operator">&gt;</span>`<br></code></pre></td></tr></table></figure></li><li><p> 2.再使用， </p></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">`<span class="hljs-operator">&lt;</span>include refid<span class="hljs-operator">=</span>&quot;id的值&quot; <span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span>`<br></code></pre></td></tr></table></figure><hr><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>数据库的属性配置文件： 把数据库连接信息放到一个单独的文件中。 和mybatis主配置文件分开。<br>目的是便于修改，保存，处理多个数据库的信息。</p><ul><li><p>在resources目录中定义一个属性配置文件， xxxx.properties ,例如 jdbc.properties<br>在属性配置文件中， 定义数据，格式是 key=value<br>key： 一般使用 . 做多级目录的。<br>例如:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> jdbc.mysql.driver, jdbc.driver, mydriver<br>  jdbc.<span class="hljs-attribute">driver</span>=com.mysql.jdbc.Driver<br>  jdbc.<span class="hljs-attribute">url</span>=jdbc:mysql//.....<br>  jdbc.<span class="hljs-attribute">username</span>=root<br>  jdbc.<span class="hljs-attribute">password</span>=123456<br>在mybatis的主配置文件，使用`&lt;property&gt; `指定文件的位置<br> 在需要使用值的地方， <span class="hljs-variable">$&#123;key&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>mapper文件，使用package指定路径</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>mappers<span class="hljs-operator">&gt;</span><br>     <span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--</span><br>     name: xml文件（mapper文件）所在的包名, 这个包中所有xml文件一次都能加载给mybatis<br>     使用package的要求：<br>       <span class="hljs-number">1.</span> mapper文件名称需要和接口名称一样， 区分大小写的一样<br>       <span class="hljs-number">2.</span> mapper文件和dao接口需要在同一目录 <span class="hljs-comment">--&gt;</span><br>    <span class="hljs-operator">&lt;</span>package name<span class="hljs-operator">=</span>&quot;com.bjpowernode.dao&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>mappers<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><hr><p>完</p><p>本文源于:<a href="http://www.bjpowernode.com/">http://www.bjpowernode.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java框架</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/evanyoungblog.gitee.io/2022/03/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/evanyoungblog.gitee.io/2022/03/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1 线程简介"></a>1 线程简介</h2><p>案例:英雄联盟，微信聊天。</p><p>多任务：边吃饭比那玩手机，边开车边打电话，但同一瞬间依旧只做了一件事。</p><p>多线程：多条路解决阻塞问题。王者荣耀。</p><h3 id="1-1-普通方法调用和多线程"><a href="#1-1-普通方法调用和多线程" class="headerlink" title="1.1 普通方法调用和多线程"></a>1.1 普通方法调用和多线程</h3><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/pic1.PNG" alt="image"></p><ul><li>进程：操作系统中运行的程序</li><li>线程：一个进程里面可以有多个线程，视频中，同时有声音，图像等</li></ul><h3 id="1-2-Process与Thread"><a href="#1-2-Process与Thread" class="headerlink" title="1.2 Process与Thread"></a>1.2 Process与Thread</h3><ul><li><p>说起线程，就不得不说下程序，程序时指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</p></li><li><p>而<strong>进程</strong>则是执行程序的一次执行过程，它是一个动态的概念。时系统资源分配的单位</p></li><li><p>通常在一个进程中可以包若干个线程，当然一个进程至少有一个线程，不然没有存在的意义。线程时CPU调度和执行的单位。</p><p>注意：很多多线程是模拟出来的，真正的多线程是指多个cpu，即多核，如服务器。<br>如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。</p></li><li><p>线程就是独立的执行路径；</p></li><li><p>在程序运行时，即使没有直接创建线程，后台也会有多个线程，如主线程，gc线程；</p></li><li><p>main()称之为主线程，为系统的入口，用于执行整个程序；</p></li><li><p>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的。</p></li><li><p>对于同一份资源的操作时，会存在资源抢夺的问题，需要加入并发控制；</p></li><li><p>线程会带来额外的开销，如cpu调度时间，并发控制开销。</p></li><li><p>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。</p></li></ul><hr><h2 id="2-线程创建"><a href="#2-线程创建" class="headerlink" title="2 线程创建"></a>2 线程创建</h2><h3 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h3><ul><li><p>自定义线程类继承Thread类</p></li><li><p>重写run()方法，编写线程执行体</p></li><li><p>创建线程对象，调用start()方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">startThread1</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;我在上班&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>startThread1 thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">startThread1</span>();<br>thread.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;我在摸鱼&quot;</span>);<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-实现Runnable接口（最核心"><a href="#2-2-实现Runnable接口（最核心" class="headerlink" title="2.2 实现Runnable接口（最核心)"></a>2.2 实现Runnable接口（最核心)</h3></li><li><p>实现MyRunnable类实现Runnable接口</p></li><li><p>实现run()方法，编写线程执行体</p></li><li><p>创建线程对象，调用start()方法启动线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">startThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>startThread2 t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">startThread2</span>();<br>Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t2);<br>thread.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;我在摸鱼&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;我在上班&quot;</span>);<br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>推荐使用Runnable对象，因为Java单继承的局限性</strong></p><ul><li>继承Thread类<ul><li>子类继承Thread类具备多线程能力</li><li>启动线程：子类对象.start()</li><li>不建议使用:避免OOP单继承局限性</li></ul></li><li>实现Runnable接口<ul><li>实现接口Runnable具有多线程能力</li><li>启动线程：传入目标对象+Thread对象.start()</li><li>推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用</li></ul></li></ul><p>案例:龟兔赛跑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 1.首先来个赛道距离，然后要离终点越来越近</span><br><span class="hljs-comment"> * 2.判断比赛是否结束</span><br><span class="hljs-comment"> * 3.打印出胜利者</span><br><span class="hljs-comment"> * 4.龟兔赛跑开始</span><br><span class="hljs-comment"> * 5.故事中乌龟赢的，兔子需要睡觉，所以我们来模拟兔子睡觉</span><br><span class="hljs-comment"> * 6.终于，乌龟赢得比赛</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Race</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br> <span class="hljs-comment">/**胜利者*/</span>  <br> <span class="hljs-keyword">private</span> String winner;  <br> <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;  <br>         <span class="hljs-keyword">if</span> (getOver(i)) &#123;  <br>             <span class="hljs-keyword">break</span>;  <br>         &#125;  <br>        <span class="hljs-comment">//兔子轻敌，睡觉去了 </span><br>         <span class="hljs-keyword">if</span>(Thread.currentThread().getName().equals(<span class="hljs-string">&quot;兔&quot;</span>)&amp;&amp;i==<span class="hljs-number">50</span>)&#123;  <br>             <span class="hljs-keyword">try</span> &#123;  <br>                 Thread.sleep(<span class="hljs-number">10</span>);  <br>                 System.out.println(<span class="hljs-string">&quot;兔子睡着了!&quot;</span>);  <br>                 &#125; <br>             <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                 e.printStackTrace();  <br>             &#125;  <br>         &#125; <br>         System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;跑了&quot;</span>+i+<span class="hljs-string">&quot;步;&quot;</span>);  <br>     &#125;  <br> &#125;  <br> <span class="hljs-comment">/**判断比赛是否结束*/</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getOver</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;  <br>     <span class="hljs-keyword">if</span>(winner!=<span class="hljs-literal">null</span>)&#123;  <br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>     &#125;<span class="hljs-keyword">else</span> &#123;  <br>         <span class="hljs-keyword">if</span>(i==<span class="hljs-number">100</span>)&#123;  <br>             winner = Thread.currentThread().getName();  <br>             System.out.println(winner+<span class="hljs-string">&quot;赢得了比赛!&quot;</span>);  <br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>         &#125;  <br>     &#125; <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br> &#125;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-type">Race</span> <span class="hljs-variable">race</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Race</span>();  <br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(race,<span class="hljs-string">&quot;兔&quot;</span>).start();  <br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(race,<span class="hljs-string">&quot;龟&quot;</span>).start();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-实现Callable接口"><a href="#2-3-实现Callable接口" class="headerlink" title="2.3 实现Callable接口"></a>2.3 实现Callable接口</h3><p>1.实现Callable接口，需要返回值类型</p><p>2.重写call方法，需要抛出异常</p><p>3.创建目标对象</p><p>4.创建执行服务：<code>ExecutorService ser=Executors.newFixedThreadPool(1);</code></p><p>5.提交执行：<code>Future&lt;Boolean&gt; result1=ser.submit(t1);</code></p><p>6.获取结果：<code>boolean r1 =result1.get()</code></p><p>7.关闭服务：<code>ser.shutdownNow();</code></p><p>用 Callable 接口改造下载图片案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.FileUtils;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-comment">//创建线程3 实现Callable 接口</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">callable 的好处</span><br><span class="hljs-comment">1、可以定义返回值</span><br><span class="hljs-comment">2、可以抛出异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Boolean&gt; &#123;<br>    <span class="hljs-keyword">private</span> String url; <span class="hljs-comment">//网络文件路径</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 需要保存为什么文件名称</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-title function_">TestCallable</span><span class="hljs-params">(String url,String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">webDownLoader</span> <span class="hljs-variable">webDownLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">webDownLoader</span>();<br>        webDownLoader.downLoader(url,name);<br>        System.out.println(<span class="hljs-string">&quot;下载了文件 ：&quot;</span>  + name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">TestCallable</span> <span class="hljs-variable">thread01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestCallable</span>(<span class="hljs-string">&quot;图片路径&quot;</span>,<span class="hljs-string">&quot;1.jpg&quot;</span>);<br>        <span class="hljs-type">TestCallable</span> <span class="hljs-variable">thread02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestCallable</span>(<span class="hljs-string">&quot;图片路径&quot;</span>,<span class="hljs-string">&quot;2.jpg&quot;</span>);<br>        <span class="hljs-type">TestCallable</span> <span class="hljs-variable">thread03</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestCallable</span>(<span class="hljs-string">&quot;图片路径&quot;</span>,<span class="hljs-string">&quot;3.jpg&quot;</span>);<br>        <span class="hljs-comment">//创建执行服务:  3 条线程</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ser</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//提交执行:</span><br>        Future&lt;Boolean&gt; result1 = ser.submit(thread01);<br>        Future&lt;Boolean&gt; result2 = ser.submit(thread02);<br>        Future&lt;Boolean&gt; result3 = ser.submit(thread03);<br>        <span class="hljs-comment">//获取结果: 就是call 方法 返回的值</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> result1.get();<br>        <span class="hljs-type">boolean</span> r2= result2.get();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">r3</span> <span class="hljs-operator">=</span> result3.get();<br>        <span class="hljs-comment">//关闭服务</span><br>        ser.shutdownNow();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//下载器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">webDownLoader</span>&#123;<br>    <span class="hljs-comment">//下载方法</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">downLoader</span><span class="hljs-params">(String url, String name)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileUtils.copyURLToFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url),<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(name));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;IO downLoader 方法异常。&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-线程状态"><a href="#3-线程状态" class="headerlink" title="3 线程状态"></a>3 线程状态</h2><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/pic2.PNG"></p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/pic3.PNG"></p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/pic4.PNG"></p><h3 id="3-1-停止线程"><a href="#3-1-停止线程" class="headerlink" title="3.1 停止线程"></a>3.1 停止线程</h3><ul><li>不推荐使用JDK提供的stop()、destroy()方法。【已废弃】</li><li>推荐线程之间停止下来</li><li>建议使用一个标志位进行终止变量</li></ul><p>当flag=false，则终止线程运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><span class="hljs-comment">//1.线程中定义线程体使用的标识</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span><span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//2.线程体使用该标识</span><br><span class="hljs-keyword">while</span> (flag) &#123;<br>System.out.println(<span class="hljs-string">&quot;run...Thread&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//3.对外提供方法改变标识</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.flag=<span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-线程休眠"><a href="#4-线程休眠" class="headerlink" title="4 线程休眠"></a>4 线程休眠</h2><ul><li>sleep(时间)指定当前线程阻塞的毫秒数；</li><li>sleep存在异常InterrupterException；</li><li>sleep时间达到后线程进入就绪状态；</li><li>sleep可以模拟网络延时，倒计时等。</li><li>每一个对象都有一个锁，sleep不会释放锁；</li></ul><p>网络延时的作用：放大问题的发生性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSleep</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            tenDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tenDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(num--);<br>            <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-线程礼让"><a href="#5-线程礼让" class="headerlink" title="5 线程礼让"></a>5 线程礼让</h2><ul><li>礼让线程，让当前正在执行的线程暂停，但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>让cpu重新调度，礼让不一定成功！看CPU心情</li></ul><p>例如：CPU正在运行A线程，此时A调用Thread.yield，变为就绪状态，Cpu重新调度A、B线程，</p><p>可能还是接着执行A线程，也有可能礼让成功，执行B线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestYield</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyYield</span> <span class="hljs-variable">myYield</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyYield</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myYield,<span class="hljs-string">&quot;a&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myYield,<span class="hljs-string">&quot;b&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyYield</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程开始执行&quot;</span>);<br>        Thread.yield();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程停止执行&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//a线程开始执行</span><br><span class="hljs-comment">//b线程开始执行</span><br><span class="hljs-comment">//b线程停止执行</span><br><span class="hljs-comment">//a线程停止执行</span><br></code></pre></td></tr></table></figure><hr><h2 id="6-线程强制执行"><a href="#6-线程强制执行" class="headerlink" title="6 线程强制执行"></a>6 线程强制执行</h2><ul><li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li><li>可以想象成插队</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestJoin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>TestJoin testJoin=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestJoin</span>();<br>Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testJoin);<br>thread.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">50</span>) &#123;<br>thread.join();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;main--&quot;</span>+i);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;join---&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-观测线程状态"><a href="#7-观测线程状态" class="headerlink" title="7 观测线程状态"></a>7 观测线程状态</h2><p><code>Thread.State</code></p><p> 线程状态。线程可以处于一下状态之一：</p><ul><li><p>NEW</p><p>尚未启动的线程处于此状态</p></li><li><p>RUNNABLE</p><p>在Java虚拟机中执行的线程处于此状态。</p></li><li><p>BLOCKED</p><p>被阻塞等待监视器锁定的线程处于此状态。</p></li><li><p>WAITING</p><p> 正在等待另一个线程执行特定动作的线程处于此状态。</p></li><li><p>TIMED_WAITING</p><p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</p></li><li><p>TERMINATED</p><p>已退出的线程处于此状态。</p></li></ul><p>一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <br>             <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span> &amp;&amp; i&lt;<span class="hljs-number">10</span>)&#123;  <br>                 <span class="hljs-keyword">try</span> &#123;  <br>                     Thread.sleep(<span class="hljs-number">1</span>);  <br>                     System.out.println(<span class="hljs-string">&quot;阻塞时的状态&quot;</span>+Thread.currentThread().getState());  <br>                 &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                     e.printStackTrace();  <br>                  &#125;  <br>             &#125; <br>             System.out.println(Thread.currentThread().getName()+i+<span class="hljs-string">&quot;线程正在执行的状态：&quot;</span>+Thread.currentThread().getState());  <br>         &#125;  <br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br> <span class="hljs-type">MyThreadState</span> <span class="hljs-variable">myThreadState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadState</span>();  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myThreadState);  <br>    Thread.<span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> thread.getState();  <br>    System.out.println(<span class="hljs-string">&quot;线程创建未启动时状态:&quot;</span>+state);  <br>    thread.start();  <br>    state = thread.getState();  <br>    System.out.println(<span class="hljs-string">&quot;线程启动后的状态:&quot;</span>+state);  <br>    <span class="hljs-keyword">while</span> (thread.getState()!= Thread.State.TERMINATED)&#123;  <br>        state = thread.getState();  <br>        System.out.println(thread.getName()+<span class="hljs-string">&quot;线程运行时状态:&quot;</span>+state);  <br>    &#125;  <br>    state = thread.getState();  <br>    System.out.println(<span class="hljs-string">&quot;线程结束状态：&quot;</span>+state);  <br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程优先级&quot;</span>+Thread.currentThread().getPriority());  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-线程优先级"><a href="#8-线程优先级" class="headerlink" title="8 线程优先级"></a>8 线程优先级</h2><ul><li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</p></li><li><p>线程的优先级用数字表示，范围从1~10.</p><ul><li>Thread.MIN_PRIORITY = 1 ;</li><li>Thread.MAX_PRIORITY = 10 ;</li><li>Thread.NORM_PRIORITY = 5 ;</li></ul></li><li><p>使用以下方式改变或获取优先级</p><ul><li>getPriority().setPriority(int xxx)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPriority</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>     System.out.println(TestPriority.currentThread().getName()+<span class="hljs-string">&quot;的优先级&quot;</span>+TestPriority.currentThread().getPriority());  <br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPriority</span> &#123;  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">TestPriority</span> <span class="hljs-variable">priority1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestPriority</span>();  <br>        <span class="hljs-type">TestPriority</span> <span class="hljs-variable">priority2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestPriority</span>();  <br>        <span class="hljs-type">TestPriority</span> <span class="hljs-variable">priority3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestPriority</span>();  <br>        <span class="hljs-type">TestPriority</span> <span class="hljs-variable">priority4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestPriority</span>();  <br>        <span class="hljs-type">TestPriority</span> <span class="hljs-variable">priority5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestPriority</span>();  <br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程优先级&quot;</span>+Thread.currentThread().getPriority());  <br>        priority1.setPriority(<span class="hljs-number">6</span>);  <br>        priority1.start();  <br><span class="hljs-comment">//        System.out.println(&quot;priority1&quot;+priority1.getPriority());  </span><br>        priority2.setPriority(<span class="hljs-number">2</span>);  <br>        priority2.start();  <br><span class="hljs-comment">//        System.out.println(&quot;priority2&quot;+priority2.getPriority());  </span><br>        priority3.setPriority(<span class="hljs-number">3</span>);  <br>        priority3.start();  <br><span class="hljs-comment">//        System.out.println(&quot;priority3&quot;+priority3.getPriority());  </span><br>        priority4.setPriority(<span class="hljs-number">8</span>);  <br>        priority4.start();  <br><span class="hljs-comment">//        System.out.println(&quot;priority4&quot;+priority4.getPriority());  </span><br>        priority5.setPriority(<span class="hljs-number">5</span>);  <br>        priority5.start();  <br><span class="hljs-comment">//        System.out.println(&quot;priority5&quot;+priority5.getPriority());  </span><br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="9-守护线程"><a href="#9-守护线程" class="headerlink" title="9 守护线程"></a>9 守护线程</h2><ul><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用的等待守护线程执行完毕</li><li>如，后台记录操作日志，监控内存，垃圾回收等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 上帝，守护线程  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">God</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>         <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;  <br>             out.println(<span class="hljs-string">&quot;上帝保佑你！&quot;</span>+l++);  <br>         &#125;  <br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * you 用户线程  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">35000</span>; i++) &#123;  <br>             out.println(<span class="hljs-string">&quot;每天都在健康的活着&quot;</span>+i);  <br>         &#125;  <br>         out.println(<span class="hljs-string">&quot;you goodBye world!&quot;</span>);  <br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 启动用户线程和守护线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadDaemon</span> &#123;  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">You</span> <span class="hljs-variable">you</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">You</span>();  <br>        <span class="hljs-type">God</span> <span class="hljs-variable">god</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">God</span>();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">youThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(you);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">godThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(god);  <br>        godThread.setDaemon(<span class="hljs-literal">true</span>);  <br>        youThread.start();  <br>        godThread.start();  <br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="10-线程同步"><a href="#10-线程同步" class="headerlink" title="10 线程同步"></a>10 线程同步</h2><p>多个线程操作同一资源。</p><h3 id="10-1并发"><a href="#10-1并发" class="headerlink" title="10.1并发"></a>10.1并发</h3><p>同个对象 被多个线程 同时操作</p><ul><li>现实生活中，我们会遇到“同个资源，多个人都想使用”的问题，比如，食堂排队打饭，每个人都想吃饭，最天然的结局方法就是，排队。一个个来。</li><li>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用</li></ul><p><strong>保证线程同步的安全性：队列加锁</strong></p><ul><li>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入<strong>锁机制synchronized</strong>，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：<ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li><li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。</li></ul></li></ul><h3 id="10-2不安全线程"><a href="#10-2不安全线程" class="headerlink" title="10.2不安全线程"></a>10.2不安全线程</h3><p>ArrayList是线程不安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadSafe</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;  <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;  <br>                <span class="hljs-keyword">synchronized</span>(arrayList)&#123;  <br>                arrayList.add(Thread.currentThread().getName());  <br>                               &#125;  <br>                &#125;).start();  <br>           &#125;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">100</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>        System.out.println(arrayList.size());  <br>   &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="10-3-同步方法"><a href="#10-3-同步方法" class="headerlink" title="10.3 同步方法"></a>10.3 同步方法</h3><ul><li><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是<strong>synchronized</strong>关键字，它包括两种用法：synchronized方法和synchronized块。</p><p><strong>同步方法：<code>public synchronized void method(int args)&#123;&#125;</code></strong></p></li><li><p>synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才获得这个锁，继续执行</p></li></ul><p><strong>缺陷：若将一个大的方法声明为synchronized将会影响效率</strong></p><ul><li>方法里面需要修改的内容才需要锁，锁太多会浪费资源。</li></ul><p> synchronized默认是锁this，同步方法锁不住的时候只能用同步块</p><ul><li><p>同步块:synchronized(Obj){}</p></li><li><p>Obj称之为同步监视器</p><ul><li>Obj可以是任何对象，但推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射】</li></ul></li><li><p>同步监视器的执行过程</p><ol><li><p>第一个线程访问，锁定同步监视器，执行其中代码。</p></li><li><p>第二个线程访问，发现同步监视器被锁定，无法访问。</p></li><li><p>第一个线程访问完毕，解锁同步监视器。</p></li><li><p>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</p></li></ol></li></ul><p>锁要锁对，默认锁this，银行取钱，锁银行没有用，要锁银行卡。</p><p>锁要锁增删改的对象，同步块放在run()方法中。</p><p><strong>银行取钱问题</strong></p><p>1.账户类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;  <br>    <span class="hljs-comment">/**余额*/</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> money;  <br>       <span class="hljs-comment">/**卡名*/</span>  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(<span class="hljs-type">int</span> money, String name)</span> &#123;<br><span class="hljs-built_in">this</span>.money=money;<br><span class="hljs-built_in">this</span>.name=name;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMoney</span><span class="hljs-params">(<span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.模拟银行取钱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 模拟银行取钱  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drawing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Account account;  <br>     <span class="hljs-comment">/**现有的钱*/</span>  <br>     <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> nowMoney;  <br>     <span class="hljs-comment">/**取出的钱*/</span>  <br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> drawingMoney;  <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Drawing</span><span class="hljs-params">( Account account,  <span class="hljs-type">int</span> drawingMoney,String name)</span> &#123;  <br>         <span class="hljs-built_in">super</span>(name);  <br>         <span class="hljs-built_in">this</span>.account = account;  <br>         <span class="hljs-built_in">this</span>.drawingMoney = drawingMoney;  <br>        &#125;  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>         <span class="hljs-keyword">synchronized</span> (account)&#123;  <br>         <span class="hljs-comment">//判断有没有钱  </span><br>         <span class="hljs-keyword">if</span>(account.getMoney()-drawingMoney&lt;<span class="hljs-number">0</span>)&#123;  <br>             out.println(<span class="hljs-string">&quot;你的账户没有那么多钱！&quot;</span>);  <br>             <span class="hljs-keyword">return</span>;  <br>         &#125;<span class="hljs-keyword">try</span> &#123;  <br>             sleep(<span class="hljs-number">100</span>);  <br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>             e.printStackTrace();  <br>         &#125;  <br>         <span class="hljs-comment">//余额  </span><br>         account.setMoney( account.getMoney() - drawingMoney);  <br>         <span class="hljs-comment">//手中的钱  </span><br>         nowMoney=nowMoney+drawingMoney;  <br>         out.println(<span class="hljs-string">&quot;余额为：&quot;</span>+account.getMoney());  <br>         out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;手中的钱：&quot;</span>+nowMoney);  <br>        &#125;  <br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多人从银行取钱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>&#123;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;工商&quot;</span>);  <br>     <span class="hljs-type">Drawing</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Drawing</span>(account, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;me&quot;</span>);  <br>     <span class="hljs-type">Drawing</span> <span class="hljs-variable">girlFriend</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Drawing</span>(account, <span class="hljs-number">89</span>, <span class="hljs-string">&quot;girlFriend&quot;</span>);  <br>     me.start();  <br>     girlFriend.start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-4-死锁"><a href="#10-4-死锁" class="headerlink" title="10.4 死锁"></a>10.4 死锁</h3><ul><li>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“<strong>两个以上对象的锁</strong>”时，就可能会发生“死锁”的问题。</li><li>产生死锁的四个必要条件:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">1.互斥条件：一个资源每次只能被一个进程使用。<br><span class="hljs-section">2.请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br>3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。<br>4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br></code></pre></td></tr></table></figure><p><strong>只要想办法破坏上述任意一个或多个条件就可以避免死锁发生。</strong></p><p>实现一个死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 口红  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lipstick</span>&#123;  <br>&#125;  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 镜子  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mirroe</span>&#123;  <br>&#125;<br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 写一个抢夺资源的方法  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>&#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>       Makeup g1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Makeup</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;小红&quot;</span>);<br>       Makeup g2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Makeup</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;小丽&quot;</span>);<br>       g1.start();<br>       g2.start();<br>   &#125;  <br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Makeup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lipstick</span> <span class="hljs-variable">lipstick</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lipstick</span>();  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Mirroe</span> <span class="hljs-variable">mirroe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mirroe</span>();  <br>    <span class="hljs-type">int</span> choice;  <br>    String girlName;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Makeup</span><span class="hljs-params">(<span class="hljs-type">int</span> choice, String girlName)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.choice = choice;  <br>        <span class="hljs-built_in">this</span>.girlName = girlName;  <br>    &#125;  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>         <span class="hljs-keyword">try</span> &#123;  <br>             makeup();  <br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>             e.printStackTrace();  <br>         &#125;  <br>     &#125;  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>         <span class="hljs-keyword">if</span>(choice==<span class="hljs-number">0</span>)&#123;  <br>             <span class="hljs-keyword">synchronized</span> (lipstick)&#123;  <br>                 System.out.println(<span class="hljs-built_in">this</span>.girlName+<span class="hljs-string">&quot;拿到口红&quot;</span>);  <br>                 Thread.sleep(<span class="hljs-number">1000</span>);  <br>                 <span class="hljs-keyword">synchronized</span> (mirroe)&#123;  <br>                     System.out.println(<span class="hljs-built_in">this</span>.girlName+<span class="hljs-string">&quot;拿到镜子&quot;</span>);  <br>                 &#125;  <br>             &#125; <br>         &#125;<span class="hljs-keyword">else</span>&#123;  <br>             <span class="hljs-keyword">synchronized</span> (mirroe)&#123;  <br>                 System.out.println(<span class="hljs-built_in">this</span>.girlName+<span class="hljs-string">&quot;拿到镜子&quot;</span>);  <br>                 Thread.sleep(<span class="hljs-number">2000</span>);  <br>                 <span class="hljs-keyword">synchronized</span> (lipstick)&#123;  <br>                     System.out.println(<span class="hljs-built_in">this</span>.girlName+<span class="hljs-string">&quot;拿到口红&quot;</span>);  <br>                 &#125;  <br>             &#125; <br>         &#125; <br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="11-Lock锁"><a href="#11-Lock锁" class="headerlink" title="11 Lock锁"></a>11 Lock锁</h2><ul><li>从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当</li><li><code>java.util.concurrent.locks.Lock</code>接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</li><li>ReentrantLock类实现了Lock，它拥有与synchronized相同得并发性和内存语义，在实现线程安全得控制中，比较常用得是ReentrantLock，可以显式加锁、释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//保证线程安全的代码；</span><br>        &#125;<br>        <span class="hljs-keyword">finally</span>&#123;<br>            lock.unlock();<br>            <span class="hljs-comment">//如果同步代码有异常，要将unlock()写入finally语句块</span><br>        &#125;<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>多人买票例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 多人买票，用lock的方式实现  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;  <br>    <span class="hljs-type">int</span> ticketNums=<span class="hljs-number">100</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>         <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123; <br>             <span class="hljs-keyword">try</span> &#123;  <br>             lock.lock(); <br>                 <span class="hljs-keyword">if</span>(ticketNums&gt;<span class="hljs-number">0</span>)&#123;  <br>                     <span class="hljs-keyword">try</span> &#123;  <br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                         e.printStackTrace();  <br>                      &#125;  <br>                 System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;买到了票&quot;</span>+ticketNums--);  <br>                  &#125;<span class="hljs-keyword">else</span> &#123;  <br>                     <span class="hljs-keyword">break</span>;  <br>                  &#125;  <br>              &#125;<span class="hljs-keyword">finally</span> &#123;  <br>                  lock.unlock();  <br>              <br>              &#125;  <br>            <br>         &#125; <br>     &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">TestLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestLock</span>(); <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(lock,<span class="hljs-string">&quot;彭于晏&quot;</span>).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(lock,<span class="hljs-string">&quot;陈冠希&quot;</span>).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(lock,<span class="hljs-string">&quot;Evan&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-1-Lock和synchronized对比"><a href="#11-1-Lock和synchronized对比" class="headerlink" title="11.1 Lock和synchronized对比"></a>11.1 Lock和synchronized对比</h3><ul><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li><li>优先使用顺序：<ul><li>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt;同步方法（在方法体之外）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义可重入锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 加锁</span><br>lock.lock();<br> <span class="hljs-comment">// 解锁         </span><br>lock.unlock();    <br></code></pre></td></tr></table></figure><hr><h2 id="12-线程协作"><a href="#12-线程协作" class="headerlink" title="12 线程协作"></a>12 线程协作</h2><h3 id="12-1生产者消费者模式"><a href="#12-1生产者消费者模式" class="headerlink" title="12.1生产者消费者模式"></a>12.1生产者消费者模式</h3><ul><li>应用场景：生产者和消费者问题<ul><li>假设仓库中只能存放一件产品,生产者将生产出来的产品放入仓库,消费者将仓库中产品取走消费.</li><li>如果仓库中没有产品﹐则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止.</li><li>如果仓库中放有产品﹐则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</li></ul></li></ul><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/pic5.png"></p><ul><li><p> <strong>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖,互为条件．</strong></p></li><li><p>对于生产者﹐没有生产产品之前，要通知消费者等待﹒而生产了产品之后﹐又需要马上通知消费者消费</p></li><li><p>对于消费者﹐在消费之后,要通知生产者已经结束消费﹐需要生产新的产品以供消费.</p></li><li><p>在生产者消费者问题中,仅有synchronized是不够的</p><ul><li><p>synchronized可阻止并发更新同一个共享资源，实现了同步</p></li><li><p>synchronized不能用来实现不同线程之间的消息传递(通信)</p></li></ul></li></ul><ul><li><p>Java提供了几个方法解决线程之间的通信问题</p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/pic6.png"></p></li></ul><p><strong>sleep 会抱着锁睡觉，wait 会释放锁</strong></p><p><strong>解决办法一</strong></p><p>并发协作模型“生产者l消费者模式”—-&gt;管程法</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">生产者:负责生产数据的模块(可能是方法﹐对象﹐线程,进程);<br>消费者:负责处理数据的模块(可能是方法﹐对象﹐线程﹐进程);<br>缓冲区:消费者不能直接使用生产者的数据﹐他们之间有个“缓冲区”<br></code></pre></td></tr></table></figure><p><strong>生产者将生产好的数据放入缓冲区,消费者从缓冲区拿出数据</strong></p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试：生产者消费者模型--&gt;利用缓冲区解决：管程法</span><br><span class="hljs-comment">//生产者，消费者，产品，缓冲区</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynContainer</span> <span class="hljs-variable">container</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynContainer</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(container).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(container).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//生产者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    SynContainer container;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(SynContainer container)</span>&#123;<br>        <span class="hljs-built_in">this</span>.container = container;<br>    &#125;<br>    <span class="hljs-comment">//生产</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            container.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Chicken</span>(i));<br>            System.out.println(<span class="hljs-string">&quot;生产了&quot;</span>+i+<span class="hljs-string">&quot;只鸡&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//消费者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    SynContainer container;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(SynContainer container)</span>&#123;<br>        <span class="hljs-built_in">this</span>.container = container;<br>    &#125;<br>    <span class="hljs-comment">//消费</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费了---&gt;&quot;</span>+container.pop().id+<span class="hljs-string">&quot;只鸡&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//产品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chicken</span>&#123;<br>    <span class="hljs-type">int</span> id;<span class="hljs-comment">// 产品编号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chicken</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//缓冲区</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynContainer</span>&#123;<br>    <span class="hljs-comment">//需要一个容器大小</span><br>    Chicken[] chickens = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chicken</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-comment">//容器计算器</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//生产者放入产品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Chicken chicken)</span>&#123;<br>        <span class="hljs-comment">//如果容器满了，就需要等待消费产品</span><br>        <span class="hljs-keyword">if</span>(count==chickens.length)&#123;<br>            <span class="hljs-comment">//生产者等待</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果没有满，我们就需要丢入产品</span><br>        chickens[count] = chicken;<br>        count++;<br>        <span class="hljs-comment">//可以通知消费者消费了</span><br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>    <span class="hljs-comment">//消费者消费产品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Chicken <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//判断能否消费</span><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//等待生产者生产，消费者等待</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果可以消费</span><br>        count--;<br>        <span class="hljs-type">Chicken</span> <span class="hljs-variable">chicken</span> <span class="hljs-operator">=</span> chickens[count];<br>        <span class="hljs-comment">//吃完了，通知生产者生产</span><br>        <span class="hljs-built_in">this</span>.notifyAll();<br>        <span class="hljs-keyword">return</span> chicken;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决办法二</strong></p><p>并发协作模型“生产者/消费者模式”—-&gt;信号灯法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试消费者和生产者问题2：信号灯法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPC2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TV</span> <span class="hljs-variable">tv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TV</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(tv).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(tv).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//生产者--&gt;演员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    TV tv;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Player</span><span class="hljs-params">(TV tv)</span>&#123;<br>        <span class="hljs-built_in">this</span>.tv = tv;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">this</span>.tv.play(<span class="hljs-string">&quot;快乐大本营播放中&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.tv.play(<span class="hljs-string">&quot;抖音，记录有钱人的美好生活&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//消费者--&gt;观众</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    TV tv;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Watcher</span><span class="hljs-params">(TV tv)</span>&#123;<br>        <span class="hljs-built_in">this</span>.tv = tv;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            tv.watch();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//产品--&gt;节目</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span>&#123;<br>    <span class="hljs-comment">// 演员表演，观众等待 T</span><br>    <span class="hljs-comment">// 观众观看，演员等待 F</span><br>    String voice; <span class="hljs-comment">// 表演的节目</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 表演</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String voice)</span>&#123;<br>        <span class="hljs-keyword">if</span> (!flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;演员表演了：&quot;</span>+voice);<br>        <span class="hljs-comment">// 通知观众观看</span><br>        <span class="hljs-built_in">this</span>.notifyAll();<span class="hljs-comment">// 通知唤醒</span><br>        <span class="hljs-built_in">this</span>.voice = voice;<br>        <span class="hljs-built_in">this</span>.flag = !<span class="hljs-built_in">this</span>.flag;<span class="hljs-comment">//flag如果是真就取假，相同是假就取真</span><br>    &#125;<br>    <span class="hljs-comment">// 观看</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watch</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;观众观看了：&quot;</span>+voice);<br>        <span class="hljs-comment">// 通知演员表演</span><br>        <span class="hljs-built_in">this</span>.notifyAll();<br>        <span class="hljs-built_in">this</span>.flag = !<span class="hljs-built_in">this</span>.flag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="13-线程池"><a href="#13-线程池" class="headerlink" title="13 线程池"></a>13 线程池</h2><ul><li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li><li>思路:  提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li><li>好处:<ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低了资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理（…）<ul><li><code>corePoolSize</code>：核心池的大小</li><li><code>maximumPoolSize</code>:最大线程数</li><li><code>keepAliveTime</code>：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li></ul><h3 id="13-1使用线程池"><a href="#13-1使用线程池" class="headerlink" title="13.1使用线程池"></a>13.1使用线程池</h3><ul><li><p>JDK 5.0起提供了线程池相关API：<strong>ExecutorService</strong> 和<strong>Executors</strong></p></li><li><p><strong>ExecutorService</strong>：真正的线程池接口。常见子类ThreadPoolExecutor</p><ul><li><code>void execute(Runnable command)</code>:执行任务/命令，没有返回值，一般哟过来执行Runnable</li><li><code>&lt;T&gt; Future&lt;T&gt;submit(Callable&lt;T&gt;task)</code>: 执行任务，有返回值，一般用来执行Callable</li><li><code>void shutdown() </code>:关闭连接池</li></ul></li><li><p><strong>Executors</strong>：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建线程池, 参数为线程池大小 </span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 2. 添加线程</span><br>service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>()); <br>service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br>service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br>service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br><span class="hljs-comment">// 3. 关闭线程池 </span><br>service.shutdown();<br></code></pre></td></tr></table></figure></li></ul><hr><p>本文完 </p><p>本文源自：<a href="https://www.bilibili.com/video/BV1V4411p7EF?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1V4411p7EF?spm_id_from=333.999.0.0</a></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理</title>
    <link href="/evanyoungblog.gitee.io/2022/03/16/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/evanyoungblog.gitee.io/2022/03/16/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="动态代理（理解）：-基于反射机制。"><a href="#动态代理（理解）：-基于反射机制。" class="headerlink" title="动态代理（理解）： 基于反射机制。"></a>动态代理（理解）： 基于反射机制。</h2><h3 id="1-什么是动态代理-？"><a href="#1-什么是动态代理-？" class="headerlink" title="1.什么是动态代理 ？"></a>1.什么是动态代理 ？</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">使用jdk的反射机制，创建对象的能力， 创建的是代理类的对象。 而不用你创建类文件。不用写java文件。<br>动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。<br>   jdk动态代理，必须有接口，目标类必须实现接口， 没有接口时，需要使用cglib动态代理<br></code></pre></td></tr></table></figure><h3 id="2-知道动态代理能做什么-？"><a href="#2-知道动态代理能做什么-？" class="headerlink" title="2.知道动态代理能做什么 ？"></a>2.知道动态代理能做什么 ？</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">可以在不改变原来目标方法功能的前提下， 可以在代理中增强自己的功能代码。<br>在程序开发中的意思：<br>   比如：你所在的项目中，有一个功能是其他人（公司的其它部门，其它小组的人）写好的，你可以使用。<br>GoNong.class ,  GoNong gn = new GoNong(), gn.print();<br>你发现这个功能，现在还缺点， 不能完全满足我项目的需要。 我需要在gn.print()执行后，需要自己在增加代码。<br>用代理实现 gn.print（）调用时， 增加自己代码， 而不用去改原来的 GoNong文件。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E6%A1%86%E6%9E%B6/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.PNG"></p><hr><h4 id="1-代理"><a href="#1-代理" class="headerlink" title="1.代理"></a>1.代理</h4><p>  代购， 中介，换ip，商家等等</p><p>  比如有一家美国的大学， 可以对全世界招生。 留学中介（代理）</p><p>  留学中介（代理）： 帮助这家美国的学校招生，  中介是学校的代理， 中介是代替学校完成招生功能。<br>     代理特点：</p><pre><code class="hljs">      1. 中介和代理他们要做的事情是一致的：  招生。      2. 中介是学校代理， 学校是目标。      3. 家长---中介（学校介绍，办入学手续）----美国学校      4. 中介是代理，不能白干活，需要收取费用。      5. 代理不让你访问到目标。</code></pre><ul><li>为什么要找中介 ？ </li></ul><ol><li>中介是专业的， 方便</li><li>家长现在不能自己去找学校。 家长没有能力访问学校。 或者美国学校不接收个人来访。</li></ol><p>&nbsp;<br>买东西都是商家卖， 商家是某个商品的代理， 你个人买东西， 肯定不会让你接触到厂家的。</p><h4 id="2-在开发中也会有这样的情况，你有a类，-本来是调用c类的方法，-完成某个功能。-但是c不让a调用。"><a href="#2-在开发中也会有这样的情况，你有a类，-本来是调用c类的方法，-完成某个功能。-但是c不让a调用。" class="headerlink" title="2.在开发中也会有这样的情况，你有a类， 本来是调用c类的方法， 完成某个功能。 但是c不让a调用。"></a>2.在开发中也会有这样的情况，你有a类， 本来是调用c类的方法， 完成某个功能。 但是c不让a调用。</h4><p>a —–不能调用 c的方法。<br>在a 和 c 直接 创建一个 b 代理，    c让b访问。<br>a –访问b—访问c</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">实际的例子：登录，注册有验证码， 验证码是手机短信。<br><br>中国移动，联通能发短信。 <br><br>中国移动，联通能有子公司，或者关联公司，他们面向社会提供短信的发送功能<br><br>张三项目发送短信----子公司，或者关联公司-----中国移动， 联通<br></code></pre></td></tr></table></figure><h4 id="3-使用代理模式的作用"><a href="#3-使用代理模式的作用" class="headerlink" title="3.使用代理模式的作用"></a>3.使用代理模式的作用</h4> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.功能增强： 在你原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强。<br>2.控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。<br></code></pre></td></tr></table></figure><h4 id="4-实现代理的方式"><a href="#4-实现代理的方式" class="headerlink" title="4.实现代理的方式"></a>4.实现代理的方式</h4><h5 id="1-静态代理-："><a href="#1-静态代理-：" class="headerlink" title="1.静态代理 ："></a>1.静态代理 ：</h5><ul><li><p>1） 代理类是自己手工实现的，自己创建一个java类，表示代理类。</p></li><li><p>2）同时你所要代理的目标类是确定的。</p><p>  特点： 1）实现简单  2）容易理解。<br>  缺点：<br>   当你的项目中，目标类和代理类很多时候，有以下的缺点：</p><pre><code class="hljs">  1）当目标类增加了， 代理类可能也需要成倍的增加。 代理类数量过多。  2）当你的接口中功能增加了， 或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多。</code></pre></li></ul><p>模拟一个用户购买u盘的行为。</p><p>用户是客户端类<br>    商家：代理，代理某个品牌的u盘。<br>    厂家：目标类。</p><p>三者的关系： 用户（客户端）—商家（代理）—厂家（目标）</p><p>商家和厂家都是卖u盘的，他们完成的功能是一致的，都是卖u盘。</p><pre><code class="hljs">  实现步骤：     1. 创建一个接口，定义卖u盘的方法， 表示你的厂家和商家做的事情。     2. 创建厂家类，实现1步骤的接口     3. 创建商家，就是代理，也需要实现1步骤中的接口。     4. 创建客户端类，调用商家的方法买一个u盘。  代理类完成的功能：       1. 目标类中方法的调用      2. 功能增强</code></pre><h4 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h4><p>​    在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。<br>​     动态代理中目标类即使很多， 1）代理类数量可以很少， 2）当你修改了接口中的方法时，不会影响代理类。</p><pre><code class="hljs">动态代理： 在程序执行过程中，使用jdk的反射机制，创建代理类对象， 并动态的指定要代理目标类。            换句话说： 动态代理是一种创建java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。                 在java中，要想创建对象：                  1.创建类文件， java文件编译为class                  2.使用构造方法，创建类的对象。动态代理的实现：     1. jdk动态代理（理解）： 使用java反射包中的类和接口实现动态代理的功能。        反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy.    2. cglib动态代理（了解）:     cglib是第三方的工具库， 创建代理对象。     cglib的原理是继承， cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法， 实现功能的修改。    因为cglib是继承，重写方法，所以要求目标类不能是final的， 方法也不能是final的。    cglib的要求目标类比较宽松， 只要能继承就可以了。    cglib在很多的框架中使用，  比如 mybatis ，spring框架中都有使用。</code></pre><p>​                        </p><ul><li><p>jdk动态代理：</p><ol><li><p>反射， Method类，表示方法。类中的方法。 通过Method可以执行某个方法。</p></li><li><p>jdk动态代理的实现<br>反射包 java.lang.reflect , 里面有三个类 ：</p><p><code>InvocationHandler</code></p><p><code>Method</code></p><p><code> Proxy</code></p><p>1).InvocationHandler 接口（调用处理器）：就一个方法invoke（）<br>invoke（）:表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中。</p><p>代理类完成的功能：</p><ol><li><p>调用目标方法，执行目标方法的功能</p></li><li><p>功能增强，在目标方法调用时，增加功能。</p><p> 方法原型：</p></li></ol></li></ol></li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">参数： Object proxy:jdk创建的代理对象，无需赋值。<br>      Method method:目标类中的方法，jdk提供method对象的<br>            Object[] args：目标类中方法的参数， jdk提供的。<br>            public Object invoke(Object proxy, Method method, Object[] args)<br></code></pre></td></tr></table></figure><p> InvocationHandler 接口：表示你的代理要干什么。</p><p>​    怎么用： 1.创建类实现接口InvocationHandler<br>​                    2.重写invoke（）方法， 把原来静态代理中代理类要完成的功能，写在这。          </p><p>​                   2）Method类：表示方法的， 确切的说就是目标类中的方法。<br>​                 作用：通过Method可以执行某个目标类的方法，Method.invoke();<br>​                    method.invoke(目标对象，方法的参数)<br>​                      Object ret = method.invoke(service2, “李四”);<br>​<br>​            说明： method.invoke（）就是用来执行目标方法的，等同于静态代理中的<br>​                     //向厂家发送订单，告诉厂家，我买了u盘，厂家发货<br>​                  float price = factory.sell(amount); //厂家的价格。</p><pre><code class="hljs">     3）Proxy类：核心的对象，创建代理对象。之前创建对象都是 new 类的构造方法()           现在我们是使用Proxy类的方法，代替new的使用。         方法： 静态方法 newProxyInstance()         作用是： 创建代理对象， 等同于静态代理中的TaoBao taoBao = new TaoBao();     参数：         1. ClassLoader loader 类加载器，负责向内存中加载对象的。 使用反射获取对象的ClassLoader              类a , a.getCalss().getClassLoader(),  目标对象的类加载器        2. Class&lt;?&gt;[] interfaces： 接口， 目标对象实现的接口，也是反射获取的。      3. InvocationHandler h : 我们自己写的，代理类要完成的功能。         返回值：就是代理对象        public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)</code></pre><p>​<br>  3. 实现动态代理的步骤：<br>    1. 创建接口，定义目标类要完成的功能<br>     2. 创建目标类实现接口<br>     3. 创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能<br>         1.调用目标方法<br>          2.增强功能</p><pre><code class="hljs"> 4.使用Proxy类的静态方法，创建代理对象。 并把返回值转为接口类型。</code></pre>]]></content>
    
    
    <categories>
      
      <category>JAVA框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA集合</title>
    <link href="/evanyoungblog.gitee.io/2022/03/15/JAVA%E9%9B%86%E5%90%88-0/"/>
    <url>/evanyoungblog.gitee.io/2022/03/15/JAVA%E9%9B%86%E5%90%88-0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><hr><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><ul><li><p>概念：对象的容器，定义了多个对象进行操作的常用方法。可实现  数组的功能。</p></li><li><p>和数组的区别：</p><p>1.数组长度固定，集合长度不固定。</p><p>2.数组可以存储基本类型和引用类型，集合只能存储引用类型。</p></li><li><p>Java引用包：java.util.*;</p></li></ul><hr><h2 id="Collection体系集合"><a href="#Collection体系集合" class="headerlink" title="Collection体系集合"></a>Collection体系集合</h2><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E9%9B%86%E5%90%88/java%E9%9B%86%E5%90%88%E5%9B%BE1.PNG"></p><hr><h2 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a>Collection父接口</h2><ul><li><p>特点：代表一组任意类型的对象，无序、无下标、不能重复。</p></li><li><p>方法：</p><ul><li><code>boolean add(Object obj) //添加一个对象。</code></li><li><code>boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。</code></li><li><code>void clear() //清空此集合中的所有对象。</code></li><li><code>boolean contains(Object o) //检查此集合中是否包含o对象。</code></li><li><code>boolean equals(Object o) //比较此集合是否与指定对象相等。</code></li><li><code>boolean isEmpty() //判断此集合是否为空。</code></li><li><code>boolean remove(Object o) //在此集合中移除o对象。</code></li><li><code>int size() //返回此集合中的元素个数。</code></li><li><code>Object[] toArray() //姜此集合转换成数组。</code></li></ul></li></ul><p>&nbsp;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Collection接口的使用（一）</span><br><span class="hljs-comment"> * 1.添加元素</span><br><span class="hljs-comment"> * 2.删除元素</span><br><span class="hljs-comment"> * 3.遍历元素</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span>&#123;<br>    pubic <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//创建集合</span><br>        Collection collection=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();        <br><span class="hljs-comment">//      * 1.添加元素</span><br>        Collection.add(<span class="hljs-string">&quot;苹果&quot;</span>);<br>        Collection.add(<span class="hljs-string">&quot;西瓜&quot;</span>);<br>        Collection.add(<span class="hljs-string">&quot;榴莲&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+collection.size());<br>        System.out.println(collection);<br><span class="hljs-comment">//      * 2.删除元素</span><br>        collection.remove(<span class="hljs-string">&quot;榴莲&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;删除之后：&quot;</span>+collection.size());<br><span class="hljs-comment">//      * 3.遍历元素</span><br>        <span class="hljs-comment">//3.1 使用增强for </span><br>        <span class="hljs-keyword">for</span>(Object object : collection)&#123;<br>            System.out.println(object);<br>        &#125;<br>        <span class="hljs-comment">//3.2 使用迭代器（迭代器专门用来遍历集合的一种方式）</span><br>        <span class="hljs-comment">//hasnext();判断是否有下一个元素</span><br>        <span class="hljs-comment">//next();获取下一个元素</span><br>        <span class="hljs-comment">//remove();删除当前元素</span><br>        Iterator iterator=collection.Itertor();<br>        <span class="hljs-keyword">while</span>(iterator.hasnext())&#123;<br>            String object=(String)iterator.next();<br>            System.out.println(s);<br>            <span class="hljs-comment">//删除操作</span><br>            <span class="hljs-comment">//collection.remove(s);引发错误：并发修改异常</span><br>            <span class="hljs-comment">//iterator.remove();应使用迭代器的方法</span><br><span class="hljs-comment">//      * 4.判断</span><br>        System.out.println(collection.contains(<span class="hljs-string">&quot;西瓜&quot;</span>));<span class="hljs-comment">//true</span><br>        System.out.println(collection.isEmpty());<span class="hljs-comment">//false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&nbsp;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Collection接口的使用（二）</span><br><span class="hljs-comment"> * 1.添加元素</span><br><span class="hljs-comment"> * 2.删除元素</span><br><span class="hljs-comment"> * 3.遍历元素</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Collection collection=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>);<br>Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">20</span>);<br>Student s3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">19</span>);<br><span class="hljs-comment">//1.添加数据</span><br>collection.add(s1);<br>collection.add(s2);<br>collection.add(s3);<br><span class="hljs-comment">//collection.add(s3);可重复添加相同对象</span><br>System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+collection.size());<br>System.out.println(collection.toString());<br><span class="hljs-comment">//2.删除数据</span><br>collection.remove(s1);<br>System.out.println(<span class="hljs-string">&quot;删除之后：&quot;</span>+collection.size());<br><span class="hljs-comment">//3.遍历数据</span><br><span class="hljs-comment">//3.1 增强for</span><br><span class="hljs-keyword">for</span>(Object object:collection) &#123;<br>Student student=(Student) object;<br>System.out.println(student.toString());<br>&#125;<br><span class="hljs-comment">//3.2迭代器</span><br><span class="hljs-comment">//迭代过程中不能使用collection的删除方法</span><br>Iterator iterator=collection.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>Student student=(Student) iterator.next();<br>System.out.println(student.toString());<br>&#125;<br><span class="hljs-comment">//4.判断和上一块代码类似。</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&nbsp;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 学生类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age +<span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&nbsp;</p><hr><h2 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h2><h2 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h2><ul><li>特点：有序、有下标、元素可以重复。</li><li>方法:<ul><li><code>void add(int index,Object o) //在index位置插入对象o。</code></li><li><code>boolean addAll(index,Collection c) //将一个集合中的元素添加到此集合中的index位置。</code></li><li><code>Object get(int index) //返回集合中指定位置的元素。</code></li><li><code>List subList(int fromIndex,int toIndex) //返回fromIndex和toIndex之间的集合元素。 </code> </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * List子接口的使用（一）</span><br><span class="hljs-comment"> * 特点：1.有序有下标 2.可以重复</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 1.添加元素</span><br><span class="hljs-comment"> * 2.删除元素</span><br><span class="hljs-comment"> * 3.遍历元素</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment"> * 5.获取位置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//1.添加元素</span><br>list.add(<span class="hljs-string">&quot;杨&quot;</span>);<br>list.add(<span class="hljs-string">&quot;李&quot;</span>);<br>list.add(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;陈&quot;</span>);<span class="hljs-comment">//插入操作</span><br>System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+list.size());<br>System.out.println(list.toString());<br><span class="hljs-comment">//2.删除元素</span><br>list.remove(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//list.remove(&quot;李&quot;);结果同上</span><br>System.out.println(<span class="hljs-string">&quot;删除之后：&quot;</span>+list.size());<br>System.out.println(list.toString());<br><span class="hljs-comment">//3.遍历元素</span><br><span class="hljs-comment">//3.1 使用for遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size();++i) &#123;<br>System.out.println(list.get(i));<br>&#125;<br><span class="hljs-comment">//3.2 使用增强for</span><br><span class="hljs-keyword">for</span>(Object object:list) &#123;<br>System.out.println(object);<br>&#125;<br><span class="hljs-comment">//3.3 使用迭代器</span><br>Iterator iterator=list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>System.out.println(iterator.next());<br>&#125;<br><span class="hljs-comment">//3.4使用列表迭代器，listIterator可以双向遍历，添加、删除及修改元素。</span><br>ListIterator listIterator=list.listIterator();<br><span class="hljs-comment">//从前往后</span><br><span class="hljs-keyword">while</span> (listIterator.hasNext()) &#123;<br>System.out.println(listIterator.next());<br>&#125;<br><span class="hljs-comment">//从后往前（此时“遍历指针”已经指向末尾）</span><br><span class="hljs-keyword">while</span>(listIterator.hasPrevious()) &#123;<br>System.out.println(listIterator.previous());<br>&#125;<br><span class="hljs-comment">//4.判断</span><br>System.out.println(list.isEmpty());<br>System.out.println(list.contains(<span class="hljs-string">&quot;杨&quot;</span>));<br><span class="hljs-comment">//5.获取位置</span><br>System.out.println(list.indexOf(<span class="hljs-string">&quot;杨&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&nbsp;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * List子接口的使用（二）</span><br><span class="hljs-comment"> * 1.添加元素</span><br><span class="hljs-comment"> * 2.删除元素</span><br><span class="hljs-comment"> * 3.遍历元素</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment"> * 5.获取位置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">//1.添加数字数据（自动装箱）</span><br>list.add(<span class="hljs-number">20</span>);<br>list.add(<span class="hljs-number">30</span>);<br>list.add(<span class="hljs-number">40</span>);<br>list.add(<span class="hljs-number">50</span>);<br>System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+list.size());<br>System.out.println(list.toString());<br><span class="hljs-comment">//2.删除元素</span><br>list.remove(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//list.remove(20);很明显数组越界错误，改成如下</span><br><span class="hljs-comment">//list.remove(Object(20));</span><br><span class="hljs-comment">//list.remove(new Integer(20));</span><br>System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+list.size());<br>System.out.println(list.toString());<br><span class="hljs-comment">//3-5不再演示，与之前类似</span><br><span class="hljs-comment">//6.补充方法subList，返回子集合，含头不含尾</span><br>List list2=list.subList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>System.out.println(list2.toString());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&nbsp;</p><hr><h2 id="List实现类"><a href="#List实现类" class="headerlink" title="List实现类"></a>List实现类</h2><p>ArrayList 【重点】</p><ul><li><p>数组结构实现，查询快、增删慢；</p></li><li><p>JDK1.2版本，运行效率快、线程不安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ArrayList的使用</span><br><span class="hljs-comment"> * 存储结构：数组；</span><br><span class="hljs-comment"> * 特点：查找遍历速度快，增删慢。</span><br><span class="hljs-comment"> * 1.添加元素</span><br><span class="hljs-comment"> * 2.删除元素</span><br><span class="hljs-comment"> * 3.遍历元素</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment"> * 5.查找</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>ArrayList arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//1.添加元素</span><br>Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;陈冠希&quot;</span>, <span class="hljs-number">21</span>);<br>Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-number">22</span>);<br>Student s3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;梁朝伟&quot;</span>, <span class="hljs-number">21</span>);<br>arrayList.add(s1);<br>arrayList.add(s2);<br>arrayList.add(s3);<br>System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+arrayList.size());<br>System.out.println(arrayList.toString());<br><span class="hljs-comment">//2.删除元素</span><br>arrayList.remove(s1);<br><span class="hljs-comment">//arrayList.remove(new Student(&quot;梁朝伟&quot;, 21));</span><br><span class="hljs-comment">//注：这样可以删除吗（不可以）？显然这是两个不同的对象。</span><br><span class="hljs-comment">//假如两个对象属性相同便认为其是同一对象，那么如何修改代码？</span><br><span class="hljs-comment">//3.遍历元素</span><br><span class="hljs-comment">//3.1使用迭代器</span><br>Iterator iterator=arrayList.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>System.out.println(iterator.next());<br>&#125;<br><span class="hljs-comment">//3.2使用列表迭代器</span><br>ListIterator listIterator=arrayList.listIterator();<br><span class="hljs-comment">//从前往后遍历</span><br><span class="hljs-keyword">while</span>(listIterator.hasNext()) &#123;<br>System.out.println(listIterator.next());<br>&#125;<br><span class="hljs-comment">//从后往前遍历</span><br><span class="hljs-keyword">while</span>(listIterator.hasPrevious()) &#123;<br>System.out.println(listIterator.previous());<br>&#125;<br><span class="hljs-comment">//4.判断</span><br>System.out.println(arrayList.isEmpty());<br><span class="hljs-comment">//System.out.println(arrayList.contains(new Student(&quot;何&quot;, 22)));</span><br><span class="hljs-comment">//注：与上文相同的问题。</span><br><span class="hljs-comment">//5.查找</span><br>System.out.println(arrayList.indexOf(s1));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>注</strong>：Object里的equals(this==obj)用地址和当前对象比较，如果想实现代码中的问题，可以在学生类中重写equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br><span class="hljs-comment">//1.是否为同一对象</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>==obj) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//2.判断是否为空</span><br><span class="hljs-keyword">if</span> (obj==<span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//3.判断是否是Student类型</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Student) &#123;<br>Student student=(Student) obj;<br><span class="hljs-comment">//4.比较属性</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.name.equals(student.getName())&amp;&amp;<span class="hljs-built_in">this</span>.age==student.age) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//不满足，返回false</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><ul><li><p>默认容量大小：<code>private static final int DEFAULT_CAPACITY = 10;</code></p></li><li><p>存放元素的数组：<code>transient Object[] elementData;</code></p></li><li><p>实际元素个数：<code>private int size;</code></p></li><li><p>创建对象时调用的无参构造函数：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是一个空的数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段源码说明当你没有向集合中添加任何元素时，集合容量为0。那么默认的10个容量怎么来的呢？</p><p>这就得看看add方法的源码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设你new了一个数组，当前容量为0，size当然也为0。这时调用add方法进入到<code>ensureCapacityInternal(size + 1);</code>该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法中的参数minCapacity传入的值为size+1也就是 1，接着我们再进入到<code>calculateCapacity(elementData, minCapacity)</code>里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>上文说过，elementData就是存放元素的数组，当前容量为0，if条件成立，返回默认容量<code>DEFAULT_CAPACITY</code>也就是10。这个值作为参数又传入<code>ensureExplicitCapacity()</code>方法中，进入该方法查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为elementData数组长度为0，所以if条件成立，调用grow方法，<strong>重要的部分来了</strong>，我们再次进入到grow方法的源码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法先声明了一个oldCapacity变量将数组长度赋给它，其值为0；又声明了一个newCapacity变量其值为<code>oldCapacity+一个增量</code>，可以发现这个增量是和原数组长度有关的量，当然在这里也为0。第一个if条件满足，newCapacity的值为10（这就是默认的容量，不理解的话再看看前面）。第二个if条件不成立，也可以不用注意，因为MAX_ARRAY_SIZE的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>最后一句话就是为elementData数组赋予了新的长度，<code>Arrays.copyOf()</code>方法返回的数组是新的数组对象，原数组对象不会改变，该拷贝不会影响原来的数组。<code>copyOf()</code>的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。</p><p>这时候再回到add的方法中，接着就向下执行<code>elementData[size++] = e;</code>ArrayList当数组长度为10每次的增量每次扩容为原来的1.5倍。</p><hr><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li>数组结构实现，查询快、增删慢；</li><li>JDK1.0版本，运行效率慢、线程安全。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Vector的演示使用</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *1.添加数据</span><br><span class="hljs-comment"> *2.删除数据</span><br><span class="hljs-comment"> *3.遍历</span><br><span class="hljs-comment"> *4.判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Vector vector=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br><span class="hljs-comment">//1.添加数据</span><br>vector.add(<span class="hljs-string">&quot;tang&quot;</span>);<br>vector.add(<span class="hljs-string">&quot;he&quot;</span>);<br>vector.add(<span class="hljs-string">&quot;yu&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+vector.size());<br><span class="hljs-comment">//2.删除数据</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * vector.remove(0); vector.remove(&quot;tang&quot;);</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//3.遍历</span><br><span class="hljs-comment">//使用枚举器</span><br>Enumeration enumeration=vector.elements();<br><span class="hljs-keyword">while</span> (enumeration.hasMoreElements()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) enumeration.nextElement();<br>System.out.println(s);<br>&#125;<br><span class="hljs-comment">//4.判断</span><br>System.out.println(vector.isEmpty());<br>System.out.println(vector.contains(<span class="hljs-string">&quot;he&quot;</span>));<br><span class="hljs-comment">//5. Vector其他方法</span><br><span class="hljs-comment">//firstElement()  lastElement()  ElementAt();</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li><p>链表结构实现，增删快，查询慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LinkedList的用法</span><br><span class="hljs-comment"> * 存储结构：双向链表</span><br><span class="hljs-comment"> * 1.添加元素</span><br><span class="hljs-comment"> * 2.删除元素</span><br><span class="hljs-comment"> * 3.遍历</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>LinkedList linkedList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;陈冠希&quot;</span>, <span class="hljs-number">21</span>);<br>Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;梁朝伟&quot;</span>, <span class="hljs-number">22</span>);<br>Student s3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-comment">//1.添加元素</span><br>linkedList.add(s1);<br>linkedList.add(s2);<br>linkedList.add(s3);<br>linkedList.add(s3);<br>System.out.println(<span class="hljs-string">&quot;元素个数：&quot;</span>+linkedList.size());<br>System.out.println(linkedList.toString());<br><span class="hljs-comment">//2.删除元素</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * linkedList.remove(new Student(&quot;唐&quot;, 21));</span><br><span class="hljs-comment"> * System.out.println(linkedList.toString());</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//3.遍历</span><br><span class="hljs-comment">//3.1 使用for</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;linkedList.size();++i) &#123;<br>System.out.println(linkedList.get(i));<br>&#125;<br><span class="hljs-comment">//3.2 使用增强for</span><br><span class="hljs-keyword">for</span>(Object object:linkedList) &#123;<br>Student student=(Student) object;<br>System.out.println(student.toString());<br>&#125;<br><span class="hljs-comment">//3.3 使用迭代器</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span>linkedList.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) iterator.next();<br>System.out.println(student.toString());<br>&#125;<br><span class="hljs-comment">//3.4 使用列表迭代器（略）</span><br><span class="hljs-comment">//4. 判断</span><br>System.out.println(linkedList.contains(s1));<br>System.out.println(linkedList.isEmpty());<br>System.out.println(linkedList.indexOf(s3));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h2><p>​    LinkedList首先有三个属性：</p><ul><li>链表大小：<code>transient int size = 0;</code></li><li>（指向）第一个结点/头结点：<code>transient Nod&lt;E&gt; first;</code></li><li>（指向）最后一个结点/尾结点：<code>transient Node&lt;E&gt; last;</code></li></ul><p>关于Node类型我们再进入到类里看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先item存放的是实际数据；next指向下一个结点而prev指向上一个结点。</p><p>Node带参构造方法的三个参数分别是前一个结点、存储的数据、后一个结点，调用这个构造方法时将它们赋值给当前对象。</p><p>LinkedList是如何添加元素的呢？先看看add方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入到linkLast方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设刚开始new了一个LinkedList对象，first和last属性都为空，调用add进入到linkLast方法。</p><p>首先创建一个Node变量 l 将last（此时为空）赋给它，然后new一个newNode变量存储数据，并且它的前驱指向l，后继指向null；再把last指向newNode。如下图所示：</p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E9%9B%86%E5%90%88/java%E9%9B%86%E5%90%88%E5%9B%BE2.PNG"></p><p>如果满足if条件，说明这是添加的第一个结点，将first指向newNode：</p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E9%9B%86%E5%90%88/java%E9%9B%86%E5%90%88%E5%9B%BE3.PNG"></p><p>至此，LinkedList对象的第一个数据添加完毕。假设需要再添加一个数据，我们可以再来走一遍，过程同上不再赘述，图示如下：</p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E5%9B%BE4.PNG"></p><hr><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2><ul><li><p>ArrayList：必须开辟连续空间，查询快，增删慢。</p></li><li><p>LinkedList：无需开辟连续空间，查询慢，增删快。</p><p><img src="https://gitee.com/yangyewen/EvanYoungBlog.gitee.io/raw/master/img/java%E9%9B%86%E5%90%88/java%E9%9B%86%E5%90%88%E5%9B%BE5.PNG"></p></li></ul><hr><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><ul><li><p>Java泛型式JDK1.5中引入的一个新特性，其本质式参数化类型，把类型作为参数传递。</p></li><li><p>常见形式又泛型类、泛型接口、泛型方法。</p></li><li><p>语法:</p><p>​    <code>&lt;T,…&gt; T称为类型占位符，表示一种引用类型。</code></p></li><li><p>好处：</p><p> <code>提高代码的重用性。</code></p><p><code>防止类型转换异常，提高代码的安全性。</code></p></li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 泛型类</span><br><span class="hljs-comment"> * 语法：类名&lt;T&gt;</span><br><span class="hljs-comment"> * T是类型占位符，表示一种引用类型，编写多个使用逗号隔开</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myGeneric</span>&lt;T&gt;&#123;<br><span class="hljs-comment">//1.创建泛型变量</span><br><span class="hljs-comment">//不能使用new来创建，因为泛型式不确定的类型，野可能拥有私密的构造方法。</span><br>T t<br><span class="hljs-comment">//2.泛型作为方法的参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(T t)</span>&#123;<br>     System.out.println(t);<br>&#125;<br><span class="hljs-comment">//泛型作为方法的返回值</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getT</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&nbsp;</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注意：</span><br><span class="hljs-comment"> * 1.泛型只能使用引用类型</span><br><span class="hljs-comment"> * 2.不同泛型类型的对象不能相互赋值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testGeneric</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br><span class="hljs-comment">//使用泛型类创建对象</span><br>myGeneric&lt;<span class="hljs-keyword">String</span>&gt; myGeneric1=<span class="hljs-keyword">new</span> <span class="hljs-type">myGeneric</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br>myGeneric1.t=<span class="hljs-string">&quot;tang&quot;</span>;<br>myGeneric1.show(<span class="hljs-string">&quot;he&quot;</span>);<br><br>myGeneric&lt;Integer&gt; myGeneric2=<span class="hljs-keyword">new</span> <span class="hljs-type">myGeneric</span>&lt;Integer&gt;();<br>myGeneric2.t=<span class="hljs-number">10</span>;<br>myGeneric2.show(<span class="hljs-number">20</span>);<br>Integer integer=myGeneric2.getT();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 泛型接口</span><br><span class="hljs-comment"> * 语法：接口名&lt;T&gt;</span><br><span class="hljs-comment"> * 注意：不能创建泛型静态常量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&lt;T&gt;&#123;<br>    <span class="hljs-comment">//创建常量</span><br>    String nameString=<span class="hljs-string">&quot;tang&quot;</span>;<br>    <br>    T <span class="hljs-title function_">server</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现接口时确定泛型类</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> clas MyInterfaceImpl <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span>&lt;String&gt;&#123;<br> <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">server</span><span class="hljs-params">(String t)</span> &#123;<br>System.out.println(t);<br><span class="hljs-keyword">return</span> t; <br>&#125;<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试</span><br>MyInterfaceImpl myInterfaceImpl=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterfaceImpl</span>();<br>myInterfaceImpl.server(<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-comment">//xxx</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现接口时不确定泛型类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterfaceImpl2</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span>&lt;T&gt;&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">server</span><span class="hljs-params">(T t)</span> &#123;<br>System.out.println(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试</span><br>MyInterfaceImpl2&lt;Integer&gt; myInterfaceImpl2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterfaceImpl2</span>&lt;Integer&gt;();<br>myInterfaceImpl2.server(<span class="hljs-number">2000</span>);<br><span class="hljs-comment">//2000</span><br></code></pre></td></tr></table></figure><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 泛型方法</span><br><span class="hljs-comment"> * 语法：&lt;T&gt; 返回类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGenericMethod</span> &#123;<br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(T t)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;泛型方法&quot;</span>+t);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试</span><br>MyGenericMethod myGenericMethod=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyGenericMethod</span>();<br>myGenericMethod.show(<span class="hljs-string">&quot;tang&quot;</span>);<br>myGenericMethod.show(<span class="hljs-number">200</span>);<br>myGenericMethod.show(<span class="hljs-number">3.14</span>);<br></code></pre></td></tr></table></figure><h5 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a><strong>泛型集合</strong></h5><ul><li><p><strong>概念</strong>：参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p></li><li><p>特点</p><p>：</p><ul><li>编译时即可检查，而非运行时抛出异常。</li><li>访问时，不必类型转换（拆箱）。</li><li>不同泛型指尖引用不能相互赋值，泛型不存在多态。</li></ul></li></ul><p>之前我们在创建LinkedList类型对象的时候并没有使用泛型，但是进到它的源码中会发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;<span class="hljs-comment">//略&#125;</span><br></code></pre></td></tr></table></figure><p>它是一个泛型类，而我之前使用的时候并没有传递，说明java语法是允许的，这个时候传递的类型是Object类，虽然它是所有类的父类，可以存储任意的类型，但是在遍历、获取元素时需要原来的类型就要进行强制转换。这个时候就会出现一些问题，假如往链表里存储了许多不同类型的数据，在强转的时候就要判断每一个原来的类型，这样就很容易出现错误。</p><hr><h2 id="Set集合概述"><a href="#Set集合概述" class="headerlink" title="Set集合概述"></a>Set集合概述</h2><h3 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a>Set子接口</h3><ul><li><p>特点：无序、无下标、元素不可重复。</p></li><li><p>方法：全部继承自Collection中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Set接口的使用</span><br><span class="hljs-comment"> * 特点：1.无序，没有下标；2.重复</span><br><span class="hljs-comment"> * 1.添加数据</span><br><span class="hljs-comment"> * 2.删除数据</span><br><span class="hljs-comment"> * 3.遍历【重点】</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Set&lt;String&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><span class="hljs-comment">//1.添加数据</span><br>set.add(<span class="hljs-string">&quot;tang&quot;</span>);<br>set.add(<span class="hljs-string">&quot;he&quot;</span>);<br>set.add(<span class="hljs-string">&quot;yu&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;数据个数：&quot;</span>+set.size());<br>System.out.println(set.toString());<span class="hljs-comment">//无序输出</span><br><span class="hljs-comment">//2.删除数据</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * set.remove(&quot;tang&quot;); System.out.println(set.toString());</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//3.遍历【重点】</span><br><span class="hljs-comment">//3.1 使用增强for</span><br><span class="hljs-keyword">for</span> (String string : set) &#123;<br>System.out.println(string);<br>&#125;<br><span class="hljs-comment">//3.2 使用迭代器</span><br>Iterator&lt;String&gt; iterator=set.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>System.out.println(iterator.next());<br>&#125;<br><span class="hljs-comment">//4.判断</span><br>System.out.println(set.contains(<span class="hljs-string">&quot;tang&quot;</span>));<br>System.out.println(set.isEmpty());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Set实现类"><a href="#Set实现类" class="headerlink" title="Set实现类"></a>Set实现类</h2><h3 id="HashSet【重点】"><a href="#HashSet【重点】" class="headerlink" title="HashSet【重点】"></a>HashSet【重点】</h3><ul><li>基于HashCode计算元素存放位置。</li><li>当存入元素的哈希码相同时，会调用equals进行确认，如结果为true，则拒绝后者存入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 人类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Peerson [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HashSet集合的使用</span><br><span class="hljs-comment"> * 存储结构：哈希表（数组+链表+红黑树）</span><br><span class="hljs-comment"> * 1.添加元素</span><br><span class="hljs-comment"> * 2.删除元素</span><br><span class="hljs-comment"> * 3.遍历</span><br><span class="hljs-comment"> * 4.判断</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>HashSet&lt;Person&gt; hashSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Person p1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;陈冠希&quot;</span>,<span class="hljs-number">21</span>);<br>Person p2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-number">22</span>);<br>Person p3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;吴彦祖&quot;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-comment">//1.添加元素</span><br>hashSet.add(p1);<br>hashSet.add(p2);<br>hashSet.add(p3);<br>        <span class="hljs-comment">//重复，添加失败</span><br>        hashSet.add(p3);<br>        <span class="hljs-comment">//直接new一个相同属性的对象，依然会被添加，不难理解。</span><br>        <span class="hljs-comment">//假如相同属性便认为是同一个对象，怎么修改？</span><br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;吴彦祖&quot;</span>, <span class="hljs-number">21</span>));<br>System.out.println(hashSet.toString());<br><span class="hljs-comment">//2.删除元素</span><br>hashSet.remove(p2);<br><span class="hljs-comment">//3.遍历</span><br><span class="hljs-comment">//3.1 增强for</span><br><span class="hljs-keyword">for</span> (Person person : hashSet) &#123;<br>System.out.println(person);<br>&#125;<br><span class="hljs-comment">//3.2 迭代器</span><br>Iterator&lt;Person&gt; iterator=hashSet.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>System.out.println(iterator.next());<br>&#125;<br><span class="hljs-comment">//4.判断</span><br>System.out.println(hashSet.isEmpty());<br>        <span class="hljs-comment">//直接new一个相同属性的对象结果输出是false，不难理解。</span><br>        <span class="hljs-comment">//注：假如相同属性便认为是同一个对象，该怎么做？</span><br>System.out.println(hashSet.contains(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;吴彦祖&quot;</span>, <span class="hljs-number">21</span>)));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注</strong>：hashSet存储过程：</p><ol><li>根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。</li><li>执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成链表。</li></ol><p>存储过程实际上就是重复依据，要实现“注”里的问题，可以重写hashCode和equals代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prime</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    result = prime * result + age;<br>    result = prime * result + ((name == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : name.hashCode());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (getClass() != obj.getClass())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Person) obj;<br>    <span class="hljs-keyword">if</span> (age != other.age)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (other.name != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!name.equals(other.name))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>hashCode方法里为什么要使用31这个数字大概有两个原因：</p><ol><li><p>31是一个质数，这样的数字在计算时可以尽量减少散列冲突。</p></li><li><p>可以提高执行效率，因为31*i=(i&lt;&lt;5)-i，31乘以一个数可以转换成移位操作，这样能快一点；但是也有网上一些人对这两点提出质疑。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul><li>基于排序顺序实现不重复。</li><li>实现了SortedSet接口，对集合元素自动排序。</li><li>元素对象的类型必须实现Comparable接口，指定排序规则。</li><li>通过CompareTo方法确定是否为重复元素。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用TreeSet保存数据</span><br><span class="hljs-comment"> * 存储结构：红黑树</span><br><span class="hljs-comment"> * 要求：元素类必须实现Comparable接口，compareTo方法返回0，认为是重复元素 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>TreeSet&lt;Person&gt; persons=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Person&gt;();<br>Person p1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tang&quot;</span>,<span class="hljs-number">21</span>);<br>Person p2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-number">22</span>);<br>Person p3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-comment">//1.添加元素</span><br>persons.add(p1);<br>persons.add(p2);<br>persons.add(p3);<br><span class="hljs-comment">//注：直接添加会报类型转换错误，需要实现Comparable接口</span><br>System.out.println(persons.toString());<br><span class="hljs-comment">//2.删除元素</span><br>persons.remove(p1);<br>persons.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-number">22</span>));<br>System.out.println(persons.toString());<br><span class="hljs-comment">//3.遍历（略）</span><br><span class="hljs-comment">//4.判断</span><br>System.out.println(persons.contains(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-number">21</span>)));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看Comparable接口的源码，发现只有一个compareTo抽象方法，在人类中实现它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-comment">//1.先按姓名比</span><br><span class="hljs-comment">//2.再按年龄比</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person o)</span> &#123;<br><span class="hljs-type">int</span> n1=<span class="hljs-built_in">this</span>.getName().compareTo(o.getName());<br><span class="hljs-type">int</span> n2=<span class="hljs-built_in">this</span>.age-o.getAge();<br><span class="hljs-keyword">return</span> n1==<span class="hljs-number">0</span>?n2:n1;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了实现Comparable接口里的比较方法，TreeSet也提供了一个带比较器Comparator的构造方法，使用匿名内部类来实现它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TreeSet的使用</span><br><span class="hljs-comment"> * Comparator：实现定制比较（比较器）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>TreeSet&lt;Person&gt; persons=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Person&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br><span class="hljs-comment">// 先按年龄比较</span><br><span class="hljs-comment">// 再按姓名比较</span><br><span class="hljs-type">int</span> n1=o1.getAge()-o2.getAge();<br><span class="hljs-type">int</span> n2=o1.getName().compareTo(o2.getName());<br><span class="hljs-keyword">return</span> n1==<span class="hljs-number">0</span>?n2:n1;<br>&#125;<br>&#125;);<br>Person p1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;陈冠希&quot;</span>,<span class="hljs-number">21</span>);<br>Person p2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;吴彦祖&quot;</span>, <span class="hljs-number">22</span>);<br>Person p3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;彭于晏&quot;</span>, <span class="hljs-number">21</span>);<br>persons.add(p1);<br>persons.add(p2);<br>persons.add(p3);<br>System.out.println(persons.toString());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来做一个小案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要求：使用TreeSet集合实现字符串按照长度进行排序</span><br><span class="hljs-comment"> * helloworld tangrui hechengyang wangzixu yuguoming</span><br><span class="hljs-comment"> * Comparator接口实现定制比较</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo6</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>TreeSet&lt;String&gt; treeSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-comment">//先比较字符串长度</span><br><span class="hljs-comment">//再比较字符串</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br><span class="hljs-type">int</span> n1=o1.length()-o2.length();<br><span class="hljs-type">int</span> n2=o1.compareTo(o2);<br><span class="hljs-keyword">return</span> n1==<span class="hljs-number">0</span>?n2:n1;<br>&#125;<br>&#125;);<br>treeSet.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>treeSet.add(<span class="hljs-string">&quot;chen&quot;</span>);<br>treeSet.add(<span class="hljs-string">&quot;liu&quot;</span>);<br>treeSet.add(<span class="hljs-string">&quot;peng&quot;</span>);<br>treeSet.add(<span class="hljs-string">&quot;liang&quot;</span>);<br>System.out.println(treeSet.toString());<br>        <span class="hljs-comment">//输出[liu, chen, peng, hello, liang]</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Map集合的实现类"><a href="#Map集合的实现类" class="headerlink" title="Map集合的实现类"></a>Map集合的实现类</h2><h2 id="HashMap-【重点】"><a href="#HashMap-【重点】" class="headerlink" title="HashMap 【重点】"></a>HashMap 【重点】</h2><ul><li>JDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 学生类</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-built_in">super</span>();<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> id;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + id + <span class="hljs-string">&quot;]&quot;</span>;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * HashMap的使用</span><br><span class="hljs-comment">   * 存储结构：哈希表（数组+链表+红黑树）</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  HashMap&lt;Student, String&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Student, String&gt;();<br>  Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;tang&quot;</span>, <span class="hljs-number">36</span>);<br>  Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-number">101</span>);<br>  Student s3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-number">10</span>);<br>  <span class="hljs-comment">//1.添加元素</span><br>  hashMap.put(s1, <span class="hljs-string">&quot;成都&quot;</span>);<br>  hashMap.put(s2, <span class="hljs-string">&quot;杭州&quot;</span>);<br>  hashMap.put(s3, <span class="hljs-string">&quot;郑州&quot;</span>);<br>  <span class="hljs-comment">//添加失败，但会更新值</span><br>  hashMap.put(s3,<span class="hljs-string">&quot;上海&quot;</span>);<br>  <span class="hljs-comment">//添加成功，不过两个属性一模一样；</span><br>  <span class="hljs-comment">//注：假如相同属性便认为是同一个对象，怎么修改？</span><br>  hashMap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-number">10</span>),<span class="hljs-string">&quot;上海&quot;</span>);<br>  System.out.println(hashMap.toString());<br>  <span class="hljs-comment">//2.删除元素</span><br>  hashMap.remove(s3);<br>  System.out.println(hashMap.toString());<br>  <span class="hljs-comment">//3.遍历</span><br>  <span class="hljs-comment">//3.1 使用keySet()遍历</span><br>  <span class="hljs-keyword">for</span> (Student key : hashMap.keySet()) &#123;<br>  System.out.println(key+<span class="hljs-string">&quot; &quot;</span>+hashMap.get(key));<br>  &#125;<br>  <span class="hljs-comment">//3.2 使用entrySet()遍历</span><br>  <span class="hljs-keyword">for</span> (Entry&lt;Student, String&gt; entry : hashMap.entrySet()) &#123;<br>  System.out.println(entry.getKey()+<span class="hljs-string">&quot; &quot;</span>+entry.getValue());<br>  &#125;<br>  <span class="hljs-comment">//4.判断</span><br>  <span class="hljs-comment">//注：同上</span><br>  System.out.println(hashMap.containsKey(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-number">10</span>)));<br>  System.out.println(hashMap.containsValue(<span class="hljs-string">&quot;成都&quot;</span>));<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>注：和之前说过的HashSet类似，重复依据是hashCode和equals方法，重写即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prime</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      result = prime * result + id;<br>      result = prime * result + ((name == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : name.hashCode());<br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (getClass() != obj.getClass())<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-type">Student</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Student) obj;<br>      <span class="hljs-keyword">if</span> (id != other.id)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (other.name != <span class="hljs-literal">null</span>)<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!name.equals(other.name))<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><ul><li>默认初始化容量：<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></li></ul><ul><li>数组最大容量：<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></li></ul><ul><li><p>默认加载因子：<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></p></li><li><p>链表调整为红黑树的链表长度阈值（JDK1.8）：<code>static final int TREEIFY_THRESHOLD = 8;</code></p></li><li><p>红黑树调整为链表的链表长度阈值（JDK1.8）：<code>static final int UNTREEIFY_THRESHOLD = 6;</code></p></li><li><p>链表调整为红黑树的数组最小阈值（JDK1.8）：<code>static final int MIN_TREEIFY_CAPACITY = 64;</code></p></li><li><p>HashMap存储的数组：<code>transient Node&lt;K,V&gt;[] table;</code></p></li><li><p>HashMap存储的元素个数：<code>transient int size;</code></p></li></ul><blockquote><ul><li>默认加载因子是什么？<ul><li>就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素个数超过了100*0.75=75，那么就会进行扩容。</li></ul></li><li>链表调整为红黑树的链表长度阈值是什么？<ul><li>假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；</li></ul></li><li>红黑树调整为链表的链表长度阈值是什么？<ul><li>当红黑树的元素个数小于该阈值时就会转换成链表。</li></ul></li><li>链表调整为红黑树的数组最小阈值是什么？<ul><li>并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。</li></ul></li></ul></blockquote><p>HashMap的数组table存储的就是一个个的Node&lt;K,V&gt;类型，很清晰地看到有一对键值，还有一个指向next的指针（以下只截取了部分源码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>      <span class="hljs-keyword">final</span> K key;<br>      V value;<br>      Node&lt;K,V&gt; next;<br>  &#125;<br></code></pre></td></tr></table></figure><p>之前的代码中在new对象时调用的是HashMap的无参构造方法，进入到该构造方法的源码查看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>发现没什么内容，只是赋值了一个默认加载因子；而在上文我们观察到源码中table和size都没有赋予初始值，说明刚创建的HashMap对象没有分配容量，并不拥有默认的16个空间大小，这样做的目的是为了节约空间，此时table为null，size为0。</p><p>当我们往对象里添加元素时调用put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>      <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>put方法把key和value传给了putVal，同时还传入了一个hash(Key)所返回的值，这是一个产生哈希值的方法，再进入到putVal方法（部分源码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                    <span class="hljs-type">boolean</span> evict)</span> &#123;<br>      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>      <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>          n = (tab = resize()).length;<br>      <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>          tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-comment">//略</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里面创建了一个tab数组和一个Node变量p，第一个if实际是判断table是否为空，而我们现在只关注刚创建HashMap对象时的状态，此时tab和table都为空，满足条件，执行内部代码，这条代码其实就是把resize()所返回的结果赋给tab，n就是tab的长度，resize顾名思义就是重新调整大小。查看resize()源码（部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>      Node&lt;K,V&gt;[] oldTab = table;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>      <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>          newCap = DEFAULT_INITIAL_CAPACITY;<br>          newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>      &#125; <br>      <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>      table = newTab;<br>      <span class="hljs-keyword">return</span> newTab;<br>  &#125;<br></code></pre></td></tr></table></figure><p>该方法首先把table及其长度赋值给oldTab和oldCap；threshold是阈值的意思，此时为0，所以前两个if先不管，最后else里newCap的值为默认初始化容量16；往下创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。然后我们再回到putVal方法，第二个if就是根据哈希码得到的tab中的一个位置是否为空，为空便直接添加元素，此时数组中无元素所以直接添加。至此HashMap对象就完成了第一个元素的添加。当添加的元素超过16*0.75=12时，就会进行扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,<span class="hljs-type">boolean</span> evict)</span>&#123;<br>      <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>          resize();<br>  &#125;<br></code></pre></td></tr></table></figure><p>扩容的代码如下（部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>      <span class="hljs-type">int</span> newCap;<br>      <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">//略&#125;</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>核心部分是else if里的移位操作，<strong>也就是说每次扩容都是原来大小的两倍</strong>。</p><ul><li>注**：额外说明的一点是在JDK1.8以前链表是头插入，JDK1.8以后链表是尾插入。</li></ul><hr><h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a><strong>HashSet源码分析</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt;<br>      <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>      <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable<br>  &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>          map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>HashSet的存储结构就是HashMap，那它的存储方式是怎样的呢？可以看一下add方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>      <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>很明了地发现它的add方法调用的就是map的put方法，把元素作为map的key传进去的。。</p><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><ul><li><p>JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。</p></li><li><p>初始容量11，加载因子0.75。</p><p>这个集合在开发过程中已经不用了，稍微了解即可。</p></li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><strong>Properties</strong></h3><ul><li>Hashtable的子类，要求key和value都是String。通常用于配置文件的读取。</li></ul><p>它继承了Hashtable的方法，与流关系密切，此处不详解。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>实现了SortedMap接口（是Map的子接口），可以对key自动排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TreeMap的使用</span><br><span class="hljs-comment"> * 存储结构：红黑树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>TreeMap&lt;Student, Integer&gt; treeMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Student, Integer&gt;();<br>Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;tang&quot;</span>, <span class="hljs-number">36</span>);<br>Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yu&quot;</span>, <span class="hljs-number">101</span>);<br>Student s3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-number">10</span>);<br><span class="hljs-comment">//1.添加元素</span><br>treeMap.put(s1, <span class="hljs-number">21</span>);<br>treeMap.put(s2, <span class="hljs-number">22</span>);<br>treeMap.put(s3, <span class="hljs-number">21</span>);<br><span class="hljs-comment">//不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小</span><br>System.out.println(treeMap.toString());<br><span class="hljs-comment">//2.删除元素</span><br>treeMap.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-number">10</span>));<br>System.out.println(treeMap.toString());<br><span class="hljs-comment">//3.遍历</span><br><span class="hljs-comment">//3.1 使用keySet()</span><br><span class="hljs-keyword">for</span> (Student key : treeMap.keySet()) &#123;<br>System.out.println(key+<span class="hljs-string">&quot; &quot;</span>+treeMap.get(key));<br>&#125;<br><span class="hljs-comment">//3.2 使用entrySet()</span><br><span class="hljs-keyword">for</span> (Entry&lt;Student, Integer&gt; entry : treeMap.entrySet()) &#123;<br>System.out.println(entry.getKey()+<span class="hljs-string">&quot; &quot;</span>+entry.getValue());<br>&#125;<br><span class="hljs-comment">//4.判断</span><br>System.out.println(treeMap.containsKey(s1));<br>System.out.println(treeMap.isEmpty());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在学生类中实现Comparable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>        <span class="hljs-type">int</span> n1=<span class="hljs-built_in">this</span>.id-o.id;<br>        <span class="hljs-keyword">return</span> n1;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外还可以使用比较器来定制比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeMap&lt;Student, Integer&gt; treeMap2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Student, Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>        <span class="hljs-comment">// 略</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a>TreeSet源码</h3><p>与HashSet类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;<br>        <span class="hljs-built_in">this</span>.m = m;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;E,Object&gt;());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TreeSet的存储结构实际上就是TreeMap，再来看其存储方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> m.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的add方法调用的就是TreeMap的put方法，将元素作为key传入到存储结构中。</p><hr><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><strong>Collections工具类</strong></h2><p><strong>概念</strong>：集合工具类，定义了除了存取以外的集合常用方法。</p><p><strong>方法</strong>：</p><ul><li><code>public static void reverse(List&lt;?&gt; list)</code>//反转集合中元素的顺序</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>//随机重置集合元素的顺序</li><li><code>public static void sort(List&lt;T&gt; list)</code>//升序排序（元素类型必须实现Comparable接口）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示Collections工具类的使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>list.add(<span class="hljs-number">20</span>);<br>list.add(<span class="hljs-number">10</span>);<br>list.add(<span class="hljs-number">30</span>);<br>list.add(<span class="hljs-number">90</span>);<br>list.add(<span class="hljs-number">70</span>);<br><br><span class="hljs-comment">//sort排序</span><br>System.out.println(list.toString());<br>Collections.sort(list);<br>System.out.println(list.toString());<br>System.out.println(<span class="hljs-string">&quot;---------&quot;</span>);<br><br><span class="hljs-comment">//binarySearch二分查找</span><br><span class="hljs-type">int</span> i=Collections.binarySearch(list, <span class="hljs-number">10</span>);<br>System.out.println(i);<br><br><span class="hljs-comment">//copy复制</span><br>List&lt;Integer&gt; list2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1=<span class="hljs-number">0</span>;i1&lt;<span class="hljs-number">5</span>;++i1) &#123;<br>list2.add(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//该方法要求目标元素容量大于等于源目标</span><br>Collections.copy(list2, list);<br>System.out.println(list2.toString());<br><br><span class="hljs-comment">//reserve反转</span><br>Collections.reverse(list2);<br>System.out.println(list2.toString());<br><br><span class="hljs-comment">//shuffle 打乱</span><br>Collections.shuffle(list2);<br>System.out.println(list2.toString());<br><br><span class="hljs-comment">//补充：list转成数组</span><br>Integer[] arr=list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br>System.out.println(arr.length);<br><span class="hljs-comment">//补充：数组转成集合 </span><br>String[] nameStrings= &#123;<span class="hljs-string">&quot;tang&quot;</span>,<span class="hljs-string">&quot;he&quot;</span>,<span class="hljs-string">&quot;yu&quot;</span>&#125;;<br><span class="hljs-comment">//受限集合，不能添加和删除</span><br>List&lt;String&gt; list3=Arrays.asList(nameStrings);<br>System.out.println(list3);<br><br><span class="hljs-comment">//注：基本类型转成集合时需要修改为包装类</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本文已完结</p><ul><li>本文源于:<a href="https://lazydog036.gitee.io/2020/10/29/JAVA%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">https://lazydog036.gitee.io/2020/10/29/JAVA%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web</title>
    <link href="/evanyoungblog.gitee.io/2022/03/15/Web/"/>
    <url>/evanyoungblog.gitee.io/2022/03/15/Web/</url>
    
    <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="1-网络通讯部分"><a href="#1-网络通讯部分" class="headerlink" title="1.网络通讯部分"></a>1.网络通讯部分</h2><h3 id="1-1TCP与UDP区别？（了解）"><a href="#1-1TCP与UDP区别？（了解）" class="headerlink" title="1.1TCP与UDP区别？（了解）"></a>1.1TCP与UDP区别？（了解）</h3><p><img src="images/%E5%9B%BE%E7%89%8728.png" alt="image text"></p><pre><code class="hljs">TCP(Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、基于IP的传输层协议。UDP是User Datagram Protocol的简称，中文名是用户数据报协议，是OSI参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。TCP和UDP都是来自于传输层的协议。传输层位于应用层和网络层之间，负责位于不同主机进程之间的通信。</code></pre><p>TCP与UDP的区别</p><p><img src="images/%E5%9B%BE%E7%89%8729.png" alt="Image text"></p><pre><code class="hljs">1.TCP基于连接UDP无连接2.TCP要求系统资源较多,UDP较少 3.TCP保证数据正确性，UDP可能丢包 4.TCP保证数据顺序，UDP不保证 </code></pre><p>&nbsp;</p><hr><h3 id="1-2什么是HTTP协议？"><a href="#1-2什么是HTTP协议？" class="headerlink" title="1.2什么是HTTP协议？"></a>1.2什么是HTTP协议？</h3><pre><code class="hljs">    客户端和服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”。     是一个基于请求与响应模式的、无状态的、应用层的协议，基于 TCP 的连接方式</code></pre><p>&nbsp;</p><hr><h3 id="1-3TCP的三次握手"><a href="#1-3TCP的三次握手" class="headerlink" title="1.3TCP的三次握手"></a>1.3TCP的三次握手</h3><pre><code class="hljs">为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</code></pre><p><img src="images/%E5%9B%BE%E7%89%8730.png" alt="image text"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">为什么要三次握手？<br>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。<br><br>SYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。<br>第一次握手：客户端给服务器发送一个SYN。客户端发送网络包，服务端收到了。服务器得出结论：客户端的发送能力，服务端的接收能力正常。<br>第二次握手：服务端收到SYN报文之后，会应答一个SYN+ACK报文。服务端发包，客户端收到了。<br>客户端得出结论：服务端的接收和发送能力，客户端的接收和发送能力正常。但是此时服务端不能确认客户端的接收能力是否正常。<br>第三次握手;客户端收到SYN+ACK报文之后，回应一个ACK报文。客户端发包，服务端收到了。服务器得出结论：客户端的接收和发送能力，自己的接收发送能力都正常。<br>通过三次握手，双方都确认对方的接收以及发送能力正常。<br></code></pre></td></tr></table></figure><p>&nbsp;</p><hr><h3 id="1-4HTTP中重定向和请求转发的区别？"><a href="#1-4HTTP中重定向和请求转发的区别？" class="headerlink" title="1.4HTTP中重定向和请求转发的区别？"></a>1.4HTTP中重定向和请求转发的区别？</h3><p><strong>实现</strong></p><pre><code class="hljs">转发：用request的getRequestDispatcher()方法得到ReuqestDispatcher对象，调用forward（）方法request.getRequestDispatcher(&quot;other.jsp&quot;).forward(request, response);重定向：调用response的sendRedirect(）方法response.sendRedirect(&quot;other.jsp&quot;);</code></pre><p><strong>区别：</strong></p><pre><code class="hljs">1&gt; 重定向2次请求，请求转发1次请求2&gt; 重定向地址栏会变，请求转发地址栏不变3&gt; 重定向是浏览器跳转，请求转发是服务器跳转4&gt; 重定向可以跳转到任意网址，请求转发只能跳转当前项目</code></pre><p>&nbsp;</p><hr><h3 id="1-5Get和Post的区别？"><a href="#1-5Get和Post的区别？" class="headerlink" title="1.5Get和Post的区别？"></a>1.5Get和Post的区别？</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。  <br>2. Get传送的数据量较小，一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。   <br>3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。        <br>4. Get执行效率却比Post方法好。Get是form提交的默认方法。<br></code></pre></td></tr></table></figure><p>   <img src="images/20210325210742187.png" alt="image text"></p><p>&nbsp;</p><hr><h2 id="2-cookie和session的区别？（必会）"><a href="#2-cookie和session的区别？（必会）" class="headerlink" title="2.cookie和session的区别？（必会）"></a>2.cookie和session的区别？（必会）</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">1.存储位置不同cookie的数据信息存放在客户端浏览器上。 session的数据信息存放在服务器上。 <br>2.存储容量不同单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。 对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。<br>3.存储方式不同cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。 session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。<br>4.隐私策略不同cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。 session存储在服务器上，不存在敏感信息泄漏的风险。<br>5. 有效期上不同开发可以通过设置cookie的属性，达到使cookie长期有效的效果。 session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。<br>6.服务器压力不同cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。 session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。 <br></code></pre></td></tr></table></figure><p>&nbsp;</p><hr><h2 id="3-Jsp和Servlet（了解）"><a href="#3-Jsp和Servlet（了解）" class="headerlink" title="3.Jsp和Servlet（了解）"></a>3.Jsp和Servlet（了解）</h2><p>1.Jsp和Servlet的区别？</p><p>相同点</p><pre><code class="hljs">jsp经编译后就变成了servlet，jsp本质就是servlet，jvm只能识别java的类，不能识别jsp代码，web容器将jsp的代码编译成jvm能够识别的java类。其实就是当你通过 http 请求一个 JSP 页面是，首先 Tomcat 会调用 service（）方法将JSP编译成为 Servlet，然后执行 Servlet。</code></pre><p>不同点</p><pre><code class="hljs">JSP侧重视图，Sevlet主要用于控制逻辑。Servlet中没有内置对象 。JSP中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</code></pre><p>2.Servlet的生命周期</p><pre><code class="hljs">// 1. servlet对象创建时，调用此方法public void init(ServletConfig servletConfig);// 2. 用户访问servlet时，调用此方法public void service(ServletRequest servletRequest, ServletResponse servletResponse);// 3. servlet对象销毁时，调用此方法public void destroy();</code></pre><p>3.JSP九大内置对象</p><pre><code class="hljs">out对象：用于向客户端、浏览器输出数据。request对象：封装了来自客户端、浏览器的各种信息。response对象：封装了服务器的响应信息。exception对象：封装了jsp程序执行过程中发生的异常和错误信息。config对象：封装了应用程序的配置信息。page对象：指向了当前jsp程序本身。session对象：用来保存会话信息。也就是说，可以实现在同一用户的不同请求之间共享数application对象：代表了当前应用程序的上下文。可以在不同的用户之间共享信息。pageContext对象：提供了对jsp页面所有对象以及命名空间的访问。</code></pre><p>&nbsp;</p><hr><h2 id="4-Ajax的介绍（必会）"><a href="#4-Ajax的介绍（必会）" class="headerlink" title="4.Ajax的介绍（必会）"></a>4.Ajax的介绍（必会）</h2><p>Ajax 即”Asynchronous JavaScript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。 </p><pre><code class="hljs">    $.ajax(&#123;     选项     &#125;)    常见的选项有:     type:请求方式,常见的值有&quot;get&quot;,&quot;post&quot;等,默认值:get     url:请求的路径,&quot;/ajax/hello&quot;     data:请求的参数,参数的常见写法有键值对或者json     方式1: name=tom&amp;pwd=123     方式2: &#123;&quot;name&quot;:&quot;tom&quot;,&quot;pwd&quot;:&quot;123&quot;&#125;     success:请求成功后的回调函数 function(返回值的参数名)&#123;&#125;     contentType:用来设置请求参数的mime类型,默认值:表单的enctype默认值 name=tom&amp;pwd=123     error:ajax请求时内部发生错误时执行的回调函数 function()&#123;&#125;     dataType:指定返回值的类型 常见值:text json     async:是否异步 默认值true </code></pre><p>Ajax应用程序的优势在于：</p><pre><code class="hljs">   1. 通过异步模式，提升了用户体验    2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少    了带宽占用    3. Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
